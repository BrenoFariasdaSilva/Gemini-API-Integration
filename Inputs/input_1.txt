%%%% CAPÍTULO 1 - INTRODUÇÃO
%%
%% Deve apresentar uma visão global da pesquisa, incluindo: breve histórico, importância e justificativa da escolha do tema,
%% delimitações do assunto, formulação de hipóteses e objetivos da pesquisa e estrutura do trabalho.

%% Título e rótulo de capítulo (rótulos não devem conter caracteres especiais, acentuados ou cedilha)

\chapter{Introdução}
\label{cap:introducao}

% Contexto e Conceitos Iniciais de SSDs.
Os avanços tecnológicos no campo de armazenamento de dados têm sido fundamentais para suportar a explosão de dados digitais nas últimas décadas. Entre as soluções de armazenamento, os \gls{ssd}s destacam-se por sua velocidade superior de acesso aos dados e resistência a choques físicos quando comparados aos \gls{hdd}s tradicionais \cite{UnderstandingSSD:Chen2009, EnergyEfficiencySSD:Park2011}. Além disso, os \gls{ssd}s utilizam memória flash para armazenar dados, o que elimina as partes móveis presentes nos \gls{hdd}s e oferece melhor desempenho em leitura e escrita \cite{UnderstandingSSD:Chen2009, EnergyEfficiencySSD:Park2011}. A memória flash usada nos \gls{ssd}s é tipicamente do tipo NAND, projetada para armazenamento de dados com alta densidade e permite acesso apenas em unidades de setores. A maioria dos \gls{ssd}s disponíveis no mercado é baseada em memórias NAND flash \cite{UnderstandingSSD:Chen2009}.

% Estrutura e Componentes dos SSDs.
Os \gls{ssd}s são dispositivos de armazenamento que utilizam memória não-volátil para guardar dados de forma permanente \cite{UnderstandingSSD:Chen2009}. Ao contrário dos discos rígidos tradicionais, que usam discos magnéticos rotativos e cabeças de leitura/escrita mecânicas, os \gls{ssd} são construídos inteiramente a partir de componentes eletrônicos. Esta estrutura compreende principalmente um controlador de memória e vários chips de memória flash \cite{SummarySSDFTL:AccelaZhao2017}. O controlador é um processador especializado que gerencia as operações de leitura e escrita na memória flash e otimiza o desempenho do \gls{ssd} por meio de algoritmos \gls{ftl}, como o ``\textit{Page-Mapping}'' \cite{EnergyEfficiencySSD:Park2011}. Os chips de memória flash, feitos geralmente de silício, são organizados internamente em uma hierarquia de ``\textit{dies}'', planos e blocos, onde cada bloco é dividido em páginas que são as menores unidades de dados para leitura e escrita. Estes blocos são as unidades de limpeza, o que destaca uma característica fundamental dos \gls{ssd}: a necessidade de apagar um bloco inteiro para reescrever qualquer parte dele \cite{EnergyEfficiencySSD:Park2011}.

% Detalhamento sobre SSDs e Algoritmos FTL.
A memória flash, no entanto, possui suas peculiaridades, como a limitação no número de ciclos de escrita - associado a operações \gls{p/e} - e a necessidade de um mecanismo de gerenciamento sofisticado chamado \gls{ftl} \cite{UnderstandingSSD:Chen2009, EnergyEfficiencySSD:Park2011}. Os algoritmos \gls{ftl} são responsáveis por fornecer uma camada de emulação, a qual deve mapear os dados entre a interface do sistema e a memória flash física, gerenciando operações de leitura, escrita e a limpeza de dados de forma eficiente para prolongar a vida útil do dispositivo \cite{FTLAlgorithms:Kwon2011, EnergyEfficiencySSD:Park2011}. Existem vários tipos algoritmos \gls{ftl}, como o \textit{page-mapping}, \textit{block-mapping} e \textit{hybrid-mapping}, cada um com suas estratégias para otimizar o desempenho e a durabilidade \cite{FTLAlgorithms:Kwon2011, EnergyEfficiencySSD:Park2011}.

% Implicações do uso de algoritmos FTL.
A utilização de algoritmos \gls{ftl} nos \gls{ssd}s tem impactos significativos no desempenho e na durabilidade desses dispositivos. Esses algoritmos são essenciais para gerenciar as limitações da memória flash, como a granularidade das operações de escrita e limpeza e o desgaste irregular dos blocos de memória. Um componente crítico desses algoritmos é o \textit{wear-leveling}, que distribui as operações de escrita e limpeza de forma uniforme por todos os blocos da memória flash para evitar o desgaste prematuro de qualquer área específica, prolongando assim a vida útil do \gls{ssd} \cite{BAST:JesungKim2002}. 

% Implicações do uso de algoritmos FTL.
Existem diferentes estratégias de mapeamento implementadas nos algoritmos \gls{ftl}, como \textit{page-mapping}, \textit{block-mapping}, e \textit{hybrid-mapping} \cite{FTLAlgorithms:Kwon2011}. O \textit{page-mapping} oferece acesso direto a qualquer página de dados, permitindo um desempenho superior em operações de leitura e escrita aleatórias, mas requer mais memória para o mapeamento de páginas \cite{EnergyEfficiencySSD:Park2011}. O \textit{block-mapping}, por outro lado, mapeia blocos inteiros, o que reduz o consumo de memória do controlador, mas pode aumentar o tempo de escrita devido à necessidade de cópias e limpezas mais frequentes \cite{EnergyEfficiencySSD:Park2011}. O \textit{hybrid-mapping} combina as técnicas de \textit{page} e \textit{block-mapping} para equilibrar desempenho e eficiência no uso da memória \cite{EnergyEfficiencySSD:Park2011}. Cada uma dessas estratégias apresenta vantagens e desvantagens que devem ser consideradas na escolha do algoritmo \gls{ftl} mais adequado para uma aplicação específica, levando em conta o \textit{trade-off} entre desempenho, durabilidade e consumo de recursos \cite{FTLAlgorithms:Kwon2011, EnergyEfficiencySSD:Park2011}.

% Problemas dos SSDs: Incertezas, desgaste, MTTF, limite escrita, fragmentação, cache para melhorar performance.
Os \gls{ssd}s enfrentam diversos problemas que impactam seu desempenho e longevidade. Uma das principais incertezas está relacionada ao desgaste das células de memória \textit{flash}, que possuem um número limitado de ciclos de escrita (\gls{p/e}), variando conforme o tipo de célula (\gls{slc}, \gls{mlc}, \gls{tlc}, \gls{qlc}) \cite{SummarySSDFTL:AccelaZhao2017, kingspecNANDFlash}. Esse desgaste reduz a vida útil dos \gls{ssd}s, levando à falha do dispositivo após exceder seu limite de escrita. Outro problema significativo é a fragmentação, tanto interna quanto externa, que afeta a eficiência das operações de leitura e escrita. A fragmentação interna ocorre dentro de um bloco, enquanto a fragmentação externa ocorre entre blocos, ambas impactando negativamente a performance do \gls{ssd} \cite{UnderstandingSSD:Chen2009}. Para mitigar esses problemas, alguns \gls{ssd}s são equipados com um \textit{buffer} de \gls{ram} externo para armazenar em cache dados ou metadados, melhorando a performance geral \cite{UnderstandingSSD:Chen2009}. Além disso, a manutenção da tabela de mapeamento e a realização de processos em segundo plano, como limpeza e \textit{readahead}, são essenciais para a gestão eficiente do \gls{ssd}. Apesar dessas soluções, a durabilidade e a confiabilidade dos \gls{ssd}s continuam sendo desafios críticos para a tecnologia \cite{UnderstandingSSD:Chen2009}.

% Objetivo do Trabalho
O presente trabalho visa realizar uma análise comparativa entre diferentes algoritmos de \gls{ftl}, avaliando como cada um impacta o desempenho, a eficiência no uso do espaço e a durabilidade dos \gls{ssd}s. Através desta análise, busca-se identificar qual algoritmo proporciona a melhor combinação de desempenho e eficiência em diferentes cenários, contribuindo assim para o entendimento dessas tecnologias de armazenamento robustas e seus impactos com relação a sustentabilidade.

% Metodologia do trabalho
A metodologia utilizada neste trabalho se baseia em uma revisão bibliográfica abrangente sobre algoritmos \gls{ftl} e uma análise comparativa dos três principais tipos: \textit{page-mapping}, \textit{block-mapping} e \textit{hybrid-mapping}. A revisão bibliográfica visa compreender os princípios de funcionamento de cada algoritmo, suas vantagens e desvantagens, e identificar as principais métricas de avaliação de desempenho, durabilidade e eficiência energética. A análise comparativa será realizada através de características observadas nas implementações dos algoritmos \gls{ftl} estudados conforme os aspectos mencionados anteriormente.

% Resultados do trabalho
Os resultados obtidos através da análise comparativa serão apresentados e discutidos, destacando as vantagens e desvantagens de cada algoritmo \gls{ftl} em diferentes cenários de uso.

% Limitações do trabalho
A pesquisa apresenta algumas limitações, como (i) Um conjunto relativamente restrito de algoritmos selecionados; (ii) Não presença de um simulador, de modo a fazer uma análise empírica entre os algoritmos. Um simulador encontrado foi o \url{https://github.com/shehbazj/simpleFTL}; (iii) A comparação dos algoritmos é limitado a um conjunto específico de três aspectos.

% Importância do Estudo
A eficácia dos algoritmos \gls{ftl} é fundamental não apenas para maximizar o desempenho e a longevidade dos \gls{ssd}s, mas também para minimizar o consumo de energia, o que é crucial tanto em centros de dados quanto em aplicações móveis. A otimização desses algoritmos pode resultar em uma redução significativa do consumo de energia e aumento da eficiência operacional \cite{EnergyEfficiencySSD:Park2011, FTLAlgorithms:Kwon2011, UnderstandingSSD:Chen2009}, essenciais para sustentar as crescentes demandas de processamento de dados e armazenamento em grande escala. Além disso, uma compreensão aprofundada da estrutura e do funcionamento dos \gls{ssd}s impacta significativamente tanto o usuário final, quanto para a indústria \cite{Claburn2008, Narayanan2009, Robb2008, Schroeder2007}, principalmente focando em termos de custo-benefício e adequação do hardware conforme as suas necessidades. Portanto, este estudo é justificado na premissa de que o entendimento da estrutura e funcionamento dos \gls{ssd}s é uma utilidade de âmbito geral.

Cabe destacar que, apesar da importância dessa área, existem poucos trabalhos disponíveis em repositórios amplamente reconhecidos como ACM ou IEEE. Isso ocorre porque a tecnologia de \gls{ssd} já atingiu um alto nível de desenvolvimento, sendo as limitações impostas pelo uso de memória flash bem conhecidas e estudadas \cite{UnderstandingSSD:Chen2009} e os estudos que detalham a estrutura dos \gls{ssd}s, seus desafios específicos, e comparações entre diferentes tipos de implementações de algoritmos \gls{ftl} em diversos cenários de uso são ainda mais nichados e escassos. Por essa razão, este trabalho se apoia em uma variedade de fontes, muitas das quais estão fora dos canais tradicionais, para construir um panorama detalhado e atualizado dessa área vital, mas pouco explorada da tecnologia.

% Estrutura do Trabalho
\section{Estrutura do Trabalho}

O presente trabalho está organizado da seguinte forma: O Capítulo \ref{cap:referencialTeorico} oferece uma revisão detalhada da literatura sobre a arquitetura dos \gls{ssd}s, a função da memória flash, e os principais algoritmos de \gls{ftl}. O Capítulo \ref{cap:trabalhosRelacionados} descreve os trabalhos relacionados com este projeto de pesquisa. O Capítulo \ref{cap:proposta} apresenta a proposta de trabalho. O Capítulo \ref{cap:metodologia} discorre sobre a metodologia utilizada para comparar os algoritmos \gls{ftl}. O Capítulo \ref{cap:resultados} apresenta e discute os resultados obtidos. O Capítulo \ref{cap:conclusao} conclui o estudo com as considerações finais e sugestões para futuras pesquisas.

%%%% CAPÍTULO 2 - REFERENCIAL TEORICO

\chapter{Referencial Teórico}
\label{cap:referencialTeorico}

Este capítulo apresenta uma revisão abrangente da estrutura dos \gls{ssd}s e dos algoritmos \gls{ftl} que são cruciais para o funcionamento desses dispositivos. A compreensão da arquitetura física e lógica dos \gls{ssd}s, bem como dos mecanismos de gerenciamento de dados implementados pelos algoritmos \gls{ftl}, é fundamental para analisar a eficiência energética e o desempenho desses dispositivos.

\section{Materiais dos SSDs}
\label{cap:materialSSDs}

Os \gls{ssd}s são construídos com base em chips semicondutores, que oferecem diversas vantagens em relação aos \gls{hdd}s tradicionais, como menor consumo de energia, tamanho mais compacto, resistência a choques e velocidades de acesso a dados significativamente maiores. A interface primitiva dos \gls{ssd}s é a mesma dos \gls{hdd}s, a \gls{sata}, mas \gls{ssd}s de alto desempenho utilizam a interface \gls{pci-e} para aproveitar ao máximo sua capacidade de processamento.

\section{Estrutura dos SSDs}
\label{cap:estruturaSSDs}

Os \gls{ssd}s são compostos por memória \textit{flash}, um tipo de armazenamento não volátil que permite leituras e escritas eletrônicas. A memória \textit{flash} difere da \textit{DRAM} em termos de acesso, pois a \textit{DRAM} permite acesso endereçável a cada \textit{byte} ou palavra, enquanto a memória \textit{flash} exige que cada página seja apagada antes de ser reescrita, e essa operação de apagamento é realizada em blocos, não em páginas individuais \cite{UnderstandingSSD:Chen2009, SSDDesignTradeOffPerformance:NitinAgrawal2008, EnergyEfficiencySSD:Park2011}.

A unidade básica de leitura e escrita na memória \textit{flash} é a ``página'', que varia de 512 \gls{b} a 8 \gls{kb} \cite{UnderstandingSSD:Chen2009, SSDDesignTradeOffPerformance:NitinAgrawal2008, HighPerformanceDesignFlashDisks:AndrewBirrell2007, EnergyEfficiencySSD:Park2011}. A unidade de operação de limpeza é o ``bloco'', que contém múltiplas páginas, de 32 a 128 \cite{UnderstandingSSD:Chen2009, SSDDesignTradeOffPerformance:NitinAgrawal2008, HighPerformanceDesignFlashDisks:AndrewBirrell2007, EnergyEfficiencySSD:Park2011}.

Um chip de memória \textit{flash} contém múltiplos \textit{DIEs}, cada um consistindo em várias \textit{planos}, que podem ser acessados paralelamente. Cada plano contém milhares de blocos, e cada bloco abriga centenas de páginas. As páginas, sendo as unidades de leitura e escrita, têm geralmente até 4 ou 8 \gls{kb}, além de um espaço oculto que contém metadados e código de correção de erros (\gls{ecc}) \cite{UnderstandingSSD:Chen2009, SSDDesignTradeOffPerformance:NitinAgrawal2008}.

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\linewidth]{figuras/SSDStructure.png}
\caption{Estrutura \textit{flash} de um \gls{ssd}. Fonte: Adaptado de \citet{SSDDesignTradeOffPerformance:NitinAgrawal2008}}
\label{fig:ssdstructure}
\end{figure}

\section{Interfaces dos SSDs}
\label{cap:interfacesSSDs}

Os \gls{ssd}s utilizam várias interfaces para se comunicarem com sistemas de computadores, sendo as principais \gls{sata}, \gls{pci-e} e \gls{nvme}. A interface \gls{sata} é uma evolução das interfaces utilizadas por discos rígidos tradicionais, adequada para o uso em \gls{ssd}s devido à sua compatibilidade e facilidade de integração. No entanto, devido à velocidade extremamente rápida dos \gls{ssd}s, a interface \gls{sata} pode se tornar um gargalo.

O \gls{pci-e} é uma interface mais rápida que se conecta diretamente ao barramento PCI, oferecendo larguras de banda substancialmente maiores. Esta interface é ideal para \gls{ssd}s de alto desempenho, pois não está limitada pelas restrições de velocidade do \gls{sata}.

\gls{nvme} é uma especificação desenvolvida especificamente para \gls{ssd}s com memória \textit{flash} acoplados via \gls{pci-e}. \gls{nvme} reduz a latência e aumenta a velocidade de entrada e saída em comparação com as soluções \gls{pci-e} anteriores, aproveitando ao máximo as capacidades dos \gls{ssd}s modernos. \gls{nvme} é considerada a interface nativa para mídias \textit{flash} devido à sua eficiência e desempenho superior.

Atualmente, os \gls{ssd}s, principalmente os de alta performance, mostram de forma abundante o uso de interfaces \gls{pci-e}, uma mudança significativa em relação às gerações anteriores que predominantemente utilizavam a interface \gls{sata}. Esta transição ocorreu por uma série de razões relacionadas principalmente ao desempenho e às necessidades de largura de banda mais elevadas que os \gls{ssd}s modernos exigem.

\subsection{Evolução das Interfaces SATA e PCI-e}
\label{cap:evolucaoInterfaces}

A interface \gls{sata}, inicialmente introduzida como \gls{sata} I ou oficialmente \gls{sata} 1.5Gb/s em 2003 \cite{PCIExpressTechnology}, foi projetada para substituir a mais antiga ATA paralela, desenvolvida inicialmente por Western Digital e Compaq em 1986 \cite{wiki:Parallel_ATA}. Este padrão oferecia uma largura de banda de 1.5Gb/s, com velocidades de transferência de até 150 MB/s. A eficiência era parcialmente limitada pela codificação 8b/10b utilizada, que reduz a taxa efetiva de transferência a aproximadamente um décimo da largura de banda total. Esta codificação foi mantida nas versões \gls{sata} I a III e nas interfaces \gls{pci-e} 1.0 e 2.0. Por outro lado, a partir da versão 3.0, \gls{pci-e} adotou a codificação 128b/130b, mais eficiente.

Com o avanço da tecnologia \gls{ssd}, as limitações de velocidade impostas pelo \gls{sata} I rapidamente se tornaram evidentes, impulsionando a busca por alternativas mais rápidas como o \gls{pci-e}.

A necessidade de velocidades de transferência mais rápidas levou ao desenvolvimento em 2004 do \gls{sata} II, fornecendo 3Gb/s de largura de banda, além de dobrar a taxa de transferência para aproximadamente 300 MB/s. Embora essa atualização tenha proporcionado uma melhoria significativa, a rápida evolução dos \gls{ssd}s logo exigiu ainda mais capacidade. Assim, em 2009, foi lançado o \gls{sata} III, também conhecido como \gls{sata} 6Gb/s, elevando a velocidade para cerca de 600 MB/s. Apesar desses avanços, a interface \gls{sata} III rapidamente se tornou um gargalo para os \gls{ssd}s de alto desempenho, que podiam processar dados muito mais rapidamente do que essa interface poderia suportar.

Diante dessas limitações, a indústria começou a adotar a interface \gls{pci-e}, que oferece uma largura de banda significativamente maior e mais flexibilidade para futuras expansões. O \gls{pci-e} começou com o \gls{pci-e} 1.0, que já era capaz de oferecer 250 MB/s por \textit{lane}. A tecnologia evoluiu para o \gls{pci-e} 2.0 e \gls{pci-e} 3.0, com taxas de transferência de 500 MB/s e 1 GB/s por \textit{lane}, respectivamente. Mais recentemente, o \gls{pci-e} 4.0 dobrou essa capacidade para 2 GB/s por \textit{lane}. Essas melhorias possibilitaram que os \gls{ssd}s de última geração ultrapassassem as restrições de desempenho impostas pela interface \gls{sata}, atendendo assim às crescentes demandas por velocidades mais altas de processamento de dados e armazenamento.

\subsection{Lanes PCI-Express}
\label{cap:lanesPCIE}

As ``\textit{lanes}'' (ou ``caminhos/vias'') do \gls{pci-e} são os canais fundamentais de transmissão de dados entre a placa-mãe e os dispositivos conectados, como os \gls{ssd}s. Cada \textit{lane} do \gls{pci-e} é composta por dois pares de fios, um para enviar e outro para receber dados, operando em um modo de comunicação serial ponto a ponto. Esta configuração permite que cada \textit{lane} transfira dados de forma independente das outras, proporcionando uma conexão dedicada e de alta velocidade. Por exemplo, no \gls{pci-e} 1.0, cada \textit{lane} é capaz de suportar uma taxa de transferência de até 250 MB/s. 

A capacidade de uma interface \gls{pci-e} é frequentemente representada pela notação ``xN'', onde ``N'' indica o número de lanes ativas; assim, uma configuração x16 possui 16 lanes, multiplicando a largura de banda total em comparação a uma configuração x1. Com o aumento do número de lanes disponíveis para uso em uma única conexão, comum em configurações mais recentes e avançadas de \gls{pci-e}, a largura de banda total disponível aumenta significativamente, permitindo assim uma comunicação mais rápida e eficiente com dispositivos de alto desempenho. Este mecanismo de \textit{lanes} multiplica a capacidade de transmissão de dados, tornando o \gls{pci-e} uma escolha ideal para aplicações que exigem altas taxas de transferência, como em servidores de alta capacidade e sistemas de edição de vídeo em alta resolução.

A migração para \gls{pci-e} não apenas aliviou os gargalos de desempenho, mas também abriu caminho para inovações tecnológicas como o \gls{nvme}, um protocolo otimizado para sistemas baseados em \gls{pci-e}, que permite um acesso mais rápido e eficiente ao armazenamento \textit{flash}. Isso demonstra como a evolução das interfaces de armazenamento foi crucial para aproveitar ao máximo as capacidades dos modernos \gls{ssd}s e sustentar o contínuo avanço da tecnologia de computadores.

\section{Tipos de Memória Flash}
\label{cap:tiposDeMemoriaFlash}

Os \gls{ssd}s são predominantemente construídos usando memória \textit{flash} \textit{NAND}, que pode ser classificada em vários tipos baseados na quantidade de dados que cada célula pode armazenar: \gls{slc}, \gls{mlc}, \gls{tlc} e \gls{qlc}.

\gls{slc} armazena um bit de dados por célula, oferecendo a maior velocidade e durabilidade, mas é também o mais caro. Este tipo é geralmente utilizado em ambientes empresariais onde a confiabilidade e a longevidade são críticas.

\gls{mlc}, por sua vez, armazena dois bits por célula e é um equilíbrio entre custo e desempenho, sendo comumente usado em \gls{ssd}s de consumo. Embora ofereça uma capacidade maior que \gls{slc}, sua durabilidade e velocidade são inferiores.

\gls{tlc} armazena três bits por célula, permitindo ainda mais densidade de armazenamento e reduzindo o custo por gigabyte. No entanto, isso também resulta em menor número de ciclos de escrita/limpeza e velocidades mais lentas em comparação com \gls{mlc}. 

Em um \gls{ssd} \gls{tlc}, existem três tipos distintos de células de armazenamento: \gls{lsb}, \gls{csb} e \gls{msb} \cite{ManagingHeterogeneousWritePerformanceinSSDs}. A \gls{lsb} armazena o bit menos significativo de cada célula, sendo a mais rápida e eficiente em termos de operações de leitura e escrita, mas também a que oferece a menor densidade de armazenamento \cite{ManagingHeterogeneousWritePerformanceinSSDs}. A \gls{csb} representa o bit intermediário, equilibrando a densidade e a velocidade de operações \cite{ManagingHeterogeneousWritePerformanceinSSDs}. Já a \gls{msb} guarda o bit mais significativo, apresentando a maior densidade de armazenamento, mas também a maior latência e desgaste nas operações de leitura e escrita \cite{ManagingHeterogeneousWritePerformanceinSSDs}. Esses diferentes tipos de células permitem que os \gls{ssd} \gls{tlc} ofereçam uma combinação de alta capacidade de armazenamento e desempenho razoável, embora a utilização intensiva das \gls{msb} possa resultar em maior desgaste e menor durabilidade do dispositivo.

As páginas são programadas separadamente conforme o tipo de bit usado, resultando em três tipos de páginas com latências de 500\(\mu\)s, 2000\(\mu\)s e 5500\(\mu\)s, respectivamente \cite{ManagingHeterogeneousWritePerformanceinSSDs}. Programar páginas \gls{csb} e \gls{msb} requer acesso prévio às páginas \gls{lsb} e \gls{csb}, o que aumenta a latência. Para mitigar esse impacto, as páginas \gls{lsb} e \gls{csb} são armazenadas em \textit{buffer} na \textit{DRAM} dos \gls{ssd}s \gls{tlc}.

Por fim, \gls{qlc} armazena quatro bits por célula, maximizando a capacidade de armazenamento e reduzindo os custos ainda mais, mas ao custo de uma menor vida útil e desempenho reduzido em comparação com as outras tecnologias.

Cada tipo de célula de memória tem seu lugar no mercado, dependendo das necessidades específicas de desempenho, durabilidade e custo.

\section{Latência dos SSDs}
\label{cap:latenciaSSDs}

A latência dos \gls{ssd}s é um fator crucial para determinar seu desempenho em diversas aplicações. De acordo com \citet{UnderstandingSSD:Chen2009}, as latências de leitura em \gls{ssd}s variam significativamente entre operações sequenciais e randômicas. Por exemplo, leituras sequenciais em \gls{ssd}s de alto desempenho possuem latências de apenas 75-90\(\mu\)s, aproximadamente 65\% menores do que leituras randômicas, que têm latências de 200-230\(\mu\)s. Em contraste, \gls{ssd}s de baixo desempenho apresentam uma distribuição de latências mais uniforme, com leituras variando entre 200-250\(\mu\)s, independentemente do padrão de acesso. Esses dados parecem estar em conformidade com os valores apresentados por \citet{EnergyEfficiencySSD:Park2011} na Figura \ref{fig:latency}/.

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\linewidth]{figuras/latency.png}
\caption{Latência média das operações de um \gls{ssd}. Fonte: Adaptado de \citet{EnergyEfficiencySSD:Park2011}}
\label{fig:latency}
\end{figure}

Essa diferença nas latências pode ser atribuída a vários fatores. Primeiramente, a memória \textit{flash} utilizada nos \gls{ssd}s permite leituras sequenciais muito mais rápidas do que leituras randômicas. Por exemplo, a memória \textit{flash} Samsung K9LBG08U0M realiza leituras randômicas em 60\(\mu\)s, enquanto leituras sequenciais são feitas em apenas 25ns \cite{UnderstandingSSD:Chen2009}. Além disso, \gls{ssd}s de médio e alto desempenho utilizam mecanismos de \textit{readahead} no controlador do \gls{ssd}, que realizam uma operação de \textit{prefetch data} para leituras sequenciais com baixo custo. Esse mecanismo, combinado com operações em múltiplos planos e \textit{interleaving} de operações entre \textit{DIEs}, permite uma leitura eficiente de páginas lógicas contínuas.

Os processos internos realizados pelos algoritmos \gls{ftl}, como \textit{garbage collection} e \textit{wear leveling}, também influenciam as latências. Esses processos ocorrem de forma assíncrona e podem aumentar a latência de operações de leitura e escrita, principalmente após processos de escrita. No entanto, leituras e escritas sequenciais parecem ser menos afetadas por esses processos. Adicionar um \textit{delay} de 10ms entre operações em \gls{ssd}s de média e alta desempenho geralmente reduz as latências para um nível comum, destacando a importância da memória cache, exploração da localidade espacial e o custo de manutenção da tabela de mapeamento e fragmentação dos dados, que são sensíveis ao padrão de acesso dos dados \cite{UnderstandingSSD:Chen2009}.

\section{Algoritmos FTL}
\label{cap:algoritmosFTL}

Um componente crítico, denominado \gls{ftl}, é implementado no controlador do \gls{ssd} para emular um disco rígido e expor uma matriz de blocos lógicos aos componentes de nível superior \cite{UnderstandingSSD:Chen2009}. O \gls{ftl} desempenha um papel essencial no desempenho e durabilidade dos \gls{ssd}s, adotando vários mecanismos sofisticados para otimizar seu funcionamento. Resumimos suas principais funções a seguir:

\textbf{Mapeamento de Blocos Lógicos} – Como as escritas na memória \textit{flash} não podem ser realizadas no mesmo local, cada escrita de uma página lógica é, na verdade, conduzida em uma página física diferente. Portanto, é necessário empregar algum mecanismo de mapeamento para mapear um endereço de bloco lógico (\gls{lba}) para um endereço de bloco físico (\gls{pba}). A granularidade do mapeamento pode ser tão grande quanto um bloco ou tão pequena quanto uma página \cite{UnderstandingSSD:Chen2009}. Embora o mapeamento a nível de página seja eficiente e flexível, ele requer uma grande quantidade de espaço de \textit{DRAM} (por exemplo, 512MB \cite{EnergyEfficiencySSD:Park2011}) para armazenar a tabela de mapeamento. Em contrapartida, o mapeamento a nível de bloco, apesar de eficiente em termos de espaço, requer uma operação cara de leitura-modificação-escrita ao escrever apenas parte de um bloco. Muitos \gls{ftl}s adotam uma abordagem híbrida usando um mapeamento a nível de bloco para gerenciar a maioria dos blocos como blocos de dados e um mapeamento a nível de página para gerenciar um pequeno conjunto de blocos de log, que funcionam como um \textit{buffer} para aceitar solicitações de escrita de maneira eficiente. Uma tabela de mapeamento é mantida na memória \textit{flash} persistente e reconstruída na \textit{DRAM} volátil durante o tempo de inicialização \cite{UnderstandingSSD:Chen2009, surveyFTL:Chung2009}.

\textbf{Recuperação de Energia}: Durante a operação do \gls{ftl}, eventos de desligamento repentino podem ocorrer, colocando em risco a integridade e consistência dos dados armazenados. A função de recuperação de energia é essencial para assegurar que as estruturas de dados do \gls{ftl} sejam devidamente salvas e que a consistência dos dados seja mantida mesmo após uma interrupção abrupta no fornecimento de energia. Este mecanismo de recuperação protege contra possíveis corrupções de dados que poderiam ocorrer devido a gravações incompletas ou à perda de metadados críticos. Assim, garantir a recuperação eficaz após quedas de energia é vital para a confiabilidade e durabilidade dos sistemas de armazenamento em \gls{ssd}s \cite{surveyFTL:Chung2009}.

\textbf{Coleta de Lixo} – Como um bloco deve ser apagado antes de ser reutilizado, um \gls{ssd} é geralmente provisionado com uma certa quantidade de blocos limpos como um \textit{pool} de alocação. Cada escrita de uma página apenas precisa invalidar a página física previamente ocupada atualizando os metadados, e os novos dados podem ser rapidamente anexados a um bloco limpo alocado do \textit{pool}, como um log, sem incorrer em uma operação de limpeza custosa de forma síncrona. Quando os blocos limpos se esgotam, um coletor de lixo varre os blocos de memória \textit{flash} e recicla as páginas invalidadas. Se um mapeamento a nível de página é usado, as páginas válidas no bloco varrido são copiadas e condensadas em um novo bloco; caso contrário, as páginas válidas precisam ser mescladas com as páginas atualizadas no mesmo bloco. Esse processo de limpeza é semelhante ao sistema de arquivos estruturado em log e pode ser realizado em segundo plano \cite{UnderstandingSSD:Chen2009}.

\textbf{Nivelamento de Desgaste} – Devido à localidade na maioria das cargas de trabalho, as escritas são frequentemente realizadas em um subconjunto de blocos (por exemplo, blocos de metadados do sistema de arquivos). Assim, alguns blocos de memória \textit{flash} podem ser reescritos com frequência e tendem a se desgastar mais rapidamente do que outros blocos. Os \gls{ftl}s geralmente empregam algum mecanismo de nivelamento de desgaste para identificar blocos frios com blocos quentes, a fim de distribuir uniformemente as escritas sobre os blocos de memória \textit{flash} \cite{UnderstandingSSD:Chen2009, surveyFTL:Chung2009}.

\section{Problemas dos SSDs}
\label{cap:problemasDosSSDs}

Os \gls{ssd}s, embora ofereçam diversas vantagens sobre os \gls{hdd}s, também apresentam alguns problemas inerentes à sua tecnologia. Entre os principais desafios estão o tipo de algoritmo \gls{ftl}, o tamanho da cache, o custo de processos em segundo plano, como  mecanismos de \textit{read ahead} e coleta de lixo, manutenção da tabela de mapeamento, o desgaste desigual dos blocos de memória, o consumo energético das operações e a fragmentação dos dados.

\textbf{Tipo de Algoritmo \gls{ftl}} – O tipo de algoritmo \gls{ftl} utilizado também influencia os problemas encontrados nos \gls{ssd}s. Algoritmos de mapeamento a nível de página (ou setores) \cite{BanPatent1995} oferecem flexibilidade e eficiência, mas requerem grande espaço de \gls{ram} para armazenar a tabela de mapeamento, sendo menos viáveis para sistemas embarcados \cite{FTLAlgorithms:Kwon2011, surveyFTL:Chung2009}. Já os algoritmos de mapeamento a nível de bloco \cite{Shinohara1999, Ban1999}, embora economizem espaço, podem incorrer em operações caras de leitura-modificação-escrita ao escrever apenas parte de um bloco. O cálculo do deslocamento dentro de um bloco é realizado pelo resto da divisão da posição desejada de escrita, com a quantidade de páginas em cada bloco \cite{FTLAlgorithms:Kwon2011, surveyFTL:Chung2009}. Por outro lado, existem esquemas de mapeamento híbrido \cite{KimLee2002}, o qual apresenta uma abordagem em que o bloco físico é mapeado pelo mapeamento de blocos e depois a posição da página dentro do bloco é mapeada via mapeamento de páginas \cite{FTLAlgorithms:Kwon2011, surveyFTL:Chung2009}. Esta abordagem melhora de forma considerável o problema de desempenho encontrado pelo uso estrito da abordagem de mapeamento em blocos e é utilizada em sistemas de armazenamento em grande escala \cite{surveyFTL:Chung2009}.

As abordagens de mapeamento variam principalmente em termos de tamanho da tabela de mapeamento, sobrecarga computacional do cálculo de endereços e custo de leitura. O mapeamento por setor utiliza uma tabela de mapeamento grande, mas não apresenta sobrecarga computacional no cálculo dos endereços, resultando em um baixo custo de leitura. Por outro lado, o mapeamento por bloco reduz o tamanho da tabela de mapeamento em comparação com o mapeamento por setor, mas introduz uma sobrecarga computacional no cálculo dos endereços, levando a um custo de leitura médio. A abordagem híbrida combina características do mapeamento por setor e por bloco, resultando em uma tabela de mapeamento com tamanho semelhante ao do mapeamento por bloco, mas com uma sobrecarga computacional no cálculo dos endereços e um custo de leitura alto. Cada abordagem oferece um \textit{trade-off} diferente entre complexidade e desempenho, sendo escolhida de acordo com as necessidades específicas do sistema.

\textbf{Uso de Abordagem Estruturada em Log} – A abordagem estruturada em log também pode ser a nível de páginas/setores \cite{Shinohara1999, Ban1999, WuChin-Hsien2006, WangYi2010} ou blocos \cite{BAST:JesungKim2002, FASTFTL:Lee2007, Kwon2008, LASTFTL:Lee2008}, a qual visa atenuar problemas de fragmentação e melhorar o desempenho, mas também introduz desafios, como a necessidade de operações de limpeza regulares que podem impactar a latência e a eficiência energética do \gls{ssd} \cite{surveyFTL:Chung2009}.

\textbf{Tamanho da Cache} – O tamanho da cache no \gls{ssd} é outro fator crítico. Caches maiores podem melhorar significativamente o desempenho de leitura e escrita ao armazenar temporariamente dados frequentemente acessados ou escritos. No entanto, caches maiores resultam em aumento do custo e o consumo de energia. Não suficiente, não basta apenas embutir mais memória, sendo que o principal fator que atrapalha o desempenho é o gerenciamento ineficiente dessa cache.

\textbf{Processos em Background e Readahead} – Processos em segundo plano, como coleta de lixo (\textit{garbage collection}) e escritas adiadas (\textit{delayed-writes}), afetam diretamente a latência das operações de leitura e escrita. O \textit{readahead}, que antecipa leituras sequenciais para melhorar a eficiência, pode se tornar ineficaz quando a fragmentação é alta, afetando negativamente o desempenho. As escritas postergadas frequentemente estão associadas à escassez de espaço de armazenamento, sendo adiadas devido à espera pela conclusão do processo de coleta de lixo.

\textbf{Custo de Manutenção da Tabela de Mapeamento} – Manter a tabela de mapeamento entre endereços lógicos e físicos requer recursos significativos, especialmente em \gls{ssd}s com mapeamento a nível de página. A fragmentação dos dados e a localidade espacial também influenciam esse custo.

\textbf{Desgaste Desigual dos Blocos de Memória} – O nivelamento de desgaste (\textit{wear leveling}) é crucial para prolongar a vida útil do \gls{ssd}, distribuindo uniformemente as operações de escrita entre todos os blocos de memória. No entanto, blocos ``quentes'' (frequentemente escritos) e ``frios'' (raramente escritos) podem levar a um desgaste desigual, exigindo algoritmos eficientes de nivelamento de desgaste \cite{UnderstandingSSD:Chen2009}. Um forma de supor o grau de eficiência e desgaste de um \gls{ssd} é pelo uso da métrica \gls{waf}. \gls{waf} representa a quantidade de gravações físicas necessárias para realizar uma gravação lógica no dispositivo de armazenamento \cite{DeallocFTL:KimJoontae2023}. Em termos simples, o \gls{waf} mede o impacto das operações de gravação no desgaste e na vida útil do \gls{ssd}. Um \gls{waf} baixo é desejável, pois indica que as gravações são eficientes e não causam um desgaste excessivo nos componentes do \gls{ssd}. Por outro lado, um \gls{waf} alto pode resultar em um aumento do desgaste e redução da vida útil do dispositivo de armazenamento \textit{flash}.

\textbf{Consumo Energético} – Algumas operações em \gls{ssd}s, como a coleta de lixo e a manutenção da tabela de mapeamento, podem ser intensivas em energia, impactando a eficiência energética geral do dispositivo. Estudos mostram que o consumo energético pode variar significativamente dependendo das operações executadas \cite{FlashStorageMemory}.

\textbf{Fragmentação (Interna e Externa)} – A fragmentação interna ocorre quando páginas inválidas se acumulam dentro dos blocos físicos de memória \textit{flash}. Quando uma página lógica é escrita em uma nova posição, a página física obsoleta é apenas invalidada pela atualização dos seus metadados. Se as escritas são distribuídas aleatoriamente no espaço de endereços de blocos lógicos, todos os blocos de memória \textit{flash} podem, eventualmente, ter uma página inválida, resultando em fragmentação interna. Isso pode impactar negativamente o desempenho, pois a eficiência de limpeza (\textit{garbage collection}) diminui drasticamente. Supondo que um bloco de limpeza tenha N páginas e cada bloco tenha apenas uma página inválida, para obter um bloco limpo, N blocos de memória \textit{flash} têm que ser varridos. Durante esse processo, são necessárias N × (N − 1) leituras de páginas, N × (N − 1) escritas de páginas e N limpezas de blocos. Além disso, páginas logicamente contínuas não são mais fisicamente contínuas, tornando o mecanismo de \textit{readahead} ineficaz e impactando o desempenho de leitura \cite{UnderstandingSSD:Chen2009}.

De acordo com a pesquisa de \citet{FTLAlgorithms:Kwon2011}, a camada \gls{ftl} vai além da simples tradução de endereços, abordando também o aprimoramento de desempenho e durabilidade. O aprimoramento de desempenho visa reduzir o número de operações de leitura, escrita e apagamento, sendo este último especialmente crítico devido ao seu alto custo em comparação com as outras operações. Quanto à durabilidade, o \gls{ftl} busca distribuir uniformemente o apagamento de blocos físicos, evitando degradação de desempenho. No entanto, se um bloco exceder o limite de ciclo de programa/apagamento, pode ocorrer falha no funcionamento, resultando em perda de dados.

%%%% CAPÍTULO 3 - TRABALHOS RELACIONADOS

\chapter{Trabalhos Relacionados}
\label{cap:trabalhosRelacionados}

Este capítulo apresenta uma revisão dos trabalhos relacionados ao estudo de algoritmos \gls{ftl} em \gls{ssd}s. Para cada trabalho relacionado, busca-se compreender os algoritmos expostos e as implicações do seu uso. Nas seções de resultados \ref{cap:resultados}, os \gls{ftl} serão comparados conforme vários aspectos, como durabilidade, desempenho, coleta de lixo, eficiência, entre outros.

\section{Visão Geral dos Algoritmos FTL}
\label{surveyFTL:Chung2009}

\citet{surveyFTL:Chung2009} aborda a importância da camada \gls{ftl} em dispositivos de armazenamento baseados em \textit{NAND flash}, destacando sua influência no desempenho geral e na organização interna dos dados para armazenamento. O estudo visa fornecer uma visão abrangente das tecnologias de tradução de endereços e dos esquemas existentes relacionados à memória flash. A metodologia utilizada envolve a análise e comparação de diferentes abordagens de \gls{ftl}. O artigo discute principalmente as arquiteturas e a taxonomia de algoritmos \gls{ftl}, sublinhando a importância da tradução de endereços, do gerenciamento de informações de mapeamento e do tamanho da tabela de mapeamento.

Os resultados apresentados por \citet{surveyFTL:Chung2009} oferecem uma descrição detalhada dos tipos de algoritmos \gls{ftl}, com foco nas operações de leitura e gravação, bem como no gerenciamento e acesso às tabelas de mapeamento. O estudo explora diversas estratégias de mapeamento, incluindo mapeamento por página, por bloco e híbrido, destacando suas vantagens e limitações específicas. Por exemplo, o mapeamento por setor possui uma grande tabela de mapeamento, mas não impõe sobrecargas computacionais adicionais, resultando em baixos custos de leitura. Em contraste, o mapeamento por bloco reduz o tamanho da tabela de mapeamento em comparação com o mapeamento por setor, porém introduz sobrecarga computacional. Finalmente, o mapeamento híbrido mantém o tamanho da tabela de mapeamento equivalente ao do mapeamento por bloco, mas acarreta um custo de leitura mais elevado devido à sua complexidade adicional.

\section{Eficiência Energética e Desempenho de SSDs}
\label{EnergyEfficiencySSD:Park2011}

\citet{EnergyEfficiencySSD:Park2011} aborda a crescente popularidade do uso de memória flash como meio de armazenamento em diversos ambientes computacionais. A proposta do estudo é analisar a eficiência energética e o desempenho de \gls{ssd}s baseados em flash. A metodologia empregada inclui a análise do \textit{overhead} de \gls{ftl}s populares sob várias cargas de trabalho, utilizando um simulador de \gls{ssd} flash. Além disso, é realizada uma análise empírica da eficiência energética e do desempenho de \gls{ssd}s disponíveis no mercado, considerando padrões de E/S em nível de bloco. Também são observadas as mudanças na eficiência energética e no desempenho de acordo com combinações de sistemas de arquivos e cargas de trabalho, utilizando uma ferramenta de macrobenchmark.

\citet{EnergyEfficiencySSD:Park2011} explica que as operações de leitura, escrita e limpeza em \gls{ssd}s apresentam latências significativamente diferentes devido à natureza das operações realizadas pela camada de tradução de endereços (\gls{ftl}) e às características físicas da memória flash \textit{NAND}. A operação de leitura é relativamente simples, pois envolve apenas a localização do endereço físico correspondente ao endereço lógico e a leitura direta dos dados, resultando em baixa latência. A operação de escrita é mais complexa, pois requer encontrar uma página apagada, escrever os novos dados, invalidar a página original, se existente, e atualizar a tabela de mapeamento, aumentando a latência devido ao ciclo de programação mais demorado da memória flash \textit{NAND}. A operação de limpeza é a mais complexa e pode introduzir latências significativas, pois envolve identificar blocos para limpeza, copiar páginas válidas para outras páginas apagadas e apagar os blocos antigos. Esta última operação é particularmente lenta devido ao tempo de apagamento substancialmente maior da memória flash \textit{NAND}. Portanto, a variação nas latências é decorrente da simplicidade da leitura, da complexidade adicional na escrita e das múltiplas etapas envolvidas na limpeza, incluindo a cópia de dados e a gestão da tabela de mapeamento.

Dentre os algoritmos estudados por \citet{EnergyEfficiencySSD:Park2011}, têm-se o algoritmo de \textit{Page-Mapping} proposto por \citet{Kawaguchi:1995}, o algoritmo de \textit{Block-Mapping} proposto por \citet{Shinohara1999} e os algoritmos de \textit{Hybrid-Mapping} BAST, FAST e LAST propostos por \citet{BAST:JesungKim2002, FASTFTL:Lee2007, LASTFTL:Lee2008}, respectivamente.

\subsection{Algoritmo de Page-Mapping}

No algoritmo de \textit{Page-Mapping} \cite{Kawaguchi:1995} estudado por \citet{EnergyEfficiencySSD:Park2011}, a \gls{ftl} mantém uma tabela de mapeamento de endereços de setores virtuais (\gls{lpn}) para endereços de setores físicos (\gls{ppn}) na memória flash. Ele emula a funcionalidade de um dispositivo de bloco normal, expondo apenas operações de leitura/gravação às camadas de software superiores e ocultando a presença da operação de apagamento. No algoritmo, cada entrada na tabela de mapeamento traduz endereços lógicos de página externos em endereços físicos de página internos na memória flash. A granularidade de cada entrada é uma página, o que implica uma relação de mapeamento um para um de uma página lógica para a página física correspondente. Quando ocorre uma operação de sobrescrita, a \gls{ftl} só precisa remapear a entrada correspondente. Este algoritmo tem uma velocidade de tradução rápida e um mecanismo de atualização de página simples, que apenas altera a entrada de mapeamento para a página sendo atualizada. No entanto, devido à necessidade de ter tantas entradas de mapeamento quanto o número de páginas, a tabela de mapeamento consome uma grande quantidade de espaço, o que pode impactar significativamente o desempenho e a eficiência energética dos dispositivos de armazenamento baseados em flash.

\subsection{Algoritmo de Block-Mapping}

No algoritmo de \textit{Block-Mapping} \cite{Shinohara1999} estudado por \citet{EnergyEfficiencySSD:Park2011}, a \gls{ftl} mantém uma tabela de mapeamento que contém entradas de mapeamento de granularidade de bloco, em contraste com o algoritmo de \textit{Page-Mapping} que utiliza granularidade de página. Cada entrada na tabela de mapeamento mapeia um endereço de página lógica para a combinação de um número de bloco físico e um número de deslocamento. O número de bloco físico e o número de deslocamento determinam a página física real que armazena os dados para a página lógica. Quando ocorre uma operação de sobrescrita, um novo bloco livre é alocado e todas as páginas, exceto a página a ser sobrescrita no bloco original, são copiadas para as páginas com os mesmos deslocamentos no novo bloco. Embora o tamanho da tabela de mapeamento no algoritmo de \textit{Block-Mapping} seja muito menor em comparação com o algoritmo de \textit{Page-Mapping}, o processamento de reescritas parciais de blocos previamente escritos pode induzir uma quantidade substancial de operações de cópia e apagamento. Isso ocorre devido à necessidade de alocar um novo bloco livre para sobrescrever uma página e copiar todas as páginas, exceto a página a ser sobrescrita, para as páginas com os mesmos deslocamentos no novo bloco.

\subsection{Algoritmos de Hybrid-Mapping}

O algoritmo BAST \citet{BAST:JesungKim2002}, também conhecido como \textit{Block Address Sector Translation}, é um tipo de algoritmo de \textit{Hybrid-Mapping} que combina características de mapeamento de bloco e setor. Neste algoritmo, a \gls{ftl} mantém uma tabela de mapeamento que contém entradas de mapeamento de granularidade de bloco, semelhante ao algoritmo de \textit{Block-Mapping}. Além disso, o BAST também utiliza setores para tradução de endereços, o que permite uma abordagem mais flexível e eficiente para o gerenciamento de dados em dispositivos de armazenamento baseados em flash. A combinação de mapeamento de bloco e setor no algoritmo BAST é projetada para alcançar otimização em três aspectos-chave dos \gls{ssd}s: desempenho, eficiência energética e vida útil. Essa abordagem permite uma gestão mais granular dos dados, reduzindo a latência de leitura e gravação para melhorar o desempenho do \gls{ssd}. Além disso, o gerenciamento eficaz dos dados e operações de E/S contribui para a redução do consumo de energia, aumentando a eficiência energética do dispositivo. Por fim, a distribuição equilibrada das operações de gravação e apagamento ao longo dos blocos e setores de memória ajuda a prolongar a durabilidade dos \gls{ssd}s, contribuindo para uma vida útil mais longa e confiável.

O algoritmo FAST \citet{FASTFTL:Lee2007}, ou \textit{Fully Associative Sector Translation}, é outro algoritmo de \textit{Hybrid-Mapping} estudado no artigo. Neste algoritmo, 5\% da capacidade total do dispositivo de armazenamento é reservada como espaço de bloco de log. O FAST utiliza uma abordagem que associa totalmente os setores para tradução de endereços, o que pode melhorar a eficiência na gestão de dados e operações de leitura/gravação em dispositivos de armazenamento baseados em flash. A alocação de espaço de bloco de log no algoritmo FAST visa reduzir o número de operações de cópia e apagamento, contribuindo para um melhor desempenho e eficiência energética dos \gls{ssd}s.

Por fim, o algoritmo LAST \citet{LASTFTL:Lee2008}, ou \textit{Log Address Sector Translation}, é mais um algoritmo de \textit{Hybrid-Mapping} analisado no estudo. Assim como o FAST, o LAST também reserva 5\% da capacidade total do dispositivo como espaço de bloco de log. Este algoritmo utiliza uma abordagem de tradução de endereços baseada em log, o que pode simplificar o gerenciamento de dados e operações de E/S em dispositivos de armazenamento flash. A estratégia de mapeamento de log no algoritmo LAST visa otimizar a eficiência na execução de operações de leitura/gravação e minimizar o impacto de operações de cópia e apagamento, resultando em um melhor desempenho e eficiência energética dos \gls{ssd}s.

\subsection{Comparação dos Algoritmos}

A comparação dos algoritmos estudados por \citet{EnergyEfficiencySSD:Park2011} pode ser resumida da seguinte forma:

\textbf{Eficiência:} O algoritmo BAST combina características de mapeamento de bloco e setor, resultando em uma eficiência intermediária em termos de gerenciamento de dados e operações de E/S. Os algoritmos FAST e LAST reservam 5\% da capacidade total do dispositivo como espaço de bloco de log, melhorando a eficiência na execução de operações de leitura/gravação e reduzindo o impacto de operações de cópia e apagamento.

\textbf{Gasto Energético:} O algoritmo BAST pode ter um consumo de energia intermediário devido à combinação de mapeamento de bloco e setor. Os algoritmos FAST e LAST, ao reservarem espaço de bloco de log, podem reduzir o consumo de energia ao minimizar operações de cópia e apagamento.

\textbf{Tamanho da Tabela de Mapeamento:} O algoritmo BAST pode exigir uma tabela de mapeamento de tamanho intermediário devido à combinação de mapeamento de bloco e setor. Os algoritmos FAST e LAST, ao reservarem espaço de bloco de log, podem ter tabelas de mapeamento menores em comparação com abordagens puramente baseadas em bloco ou página.

\textbf{Desgaste:} O algoritmo BAST pode apresentar um desgaste moderado devido à combinação de mapeamento de bloco e setor. Os algoritmos FAST e LAST, ao minimizarem operações de cópia e apagamento, podem reduzir o desgaste em comparação com abordagens que não utilizam espaço de bloco de log.

\textbf{Desempenho:} O desempenho dos algoritmos pode variar dependendo do tipo de carga de trabalho e das características específicas do sistema. Em geral, os algoritmos FAST e LAST, ao reservarem espaço de bloco de log, podem ter um desempenho melhor em termos de latência de escrita e leitura em comparação com o algoritmo BAST. Essa comparação destaca as diferentes trade-offs e características dos algoritmos estudados em relação à eficiência, consumo de energia, tamanho da tabela de mapeamento, desgaste e desempenho. A escolha do algoritmo mais adequado dependerá das necessidades específicas do sistema e das metas de otimização, levando em consideração os diferentes aspectos mencionados acima.

\subsection{Conclusões}

Os resultados de \citet{EnergyEfficiencySSD:Park2011} destacam a importância de considerar tanto o desempenho quanto a eficiência energética ao projetar sistemas de armazenamento baseados em flash. A análise abrangente realizada fornece informações valiosas para desenvolvedores de sistemas de armazenamento e engenheiros de software, visando projetar soluções que atendam às características de energia e desempenho dos dispositivos de armazenamento baseados em flash. Portanto, o estudo abordou a necessidade de melhorar a eficiência energética e o desempenho dos sistemas de armazenamento baseados em flash, fornecendo \textit{insights} e análises detalhadas para orientar o desenvolvimento de soluções mais eficazes e adequadas às demandas atuais do mercado de armazenamento de dados.

\section{Classificação e Análise de Algoritmos FTL}
\label{FTLAlgorithms:Kwon2011}

\citet{FTLAlgorithms:Kwon2011} apresentou uma revisão abrangente dos algoritmos \gls{ftl} em 2011, similar à proposta por \cite{surveyFTL:Chung2009}, porém com um conjunto extensivamente maior de algoritmos. No artigo, os algoritmos \gls{ftl} são classificados com base na complexidade: básicos e avançados. Além disso, eles são categorizados de acordo com suas principais funções: melhoria de desempenho e aumento da durabilidade. Dentro de cada classificação, os algoritmos são subdivididos em diversos esquemas, dependendo dos métodos adotados para alcançar seus objetivos. Essa revisão é fundamental para entender como diferentes algoritmos gerenciam as operações de escrita e leitura em \gls{ssd}s, buscando otimizar tanto o desempenho quanto a durabilidade dos dispositivos.

Os algoritmos \gls{ftl} básicos apresentados por \citet{FTLAlgorithms:Kwon2011} são baseados em mapeamento de páginas/setores \cite{BanPatent1995}, mapeamento de blocos \cite{Shinohara1999, Ban1999}, e mapeamento híbrido \cite{KimLee2002}. Esses métodos podem incluir esquemas baseados em log de páginas/setores \cite{Shinohara1999, Ban1999, WuChin-Hsien2006, WangYi2010} e log de blocos \cite{BAST:JesungKim2002, FASTFTL:Lee2007, Kwon2008, LASTFTL:Lee2008}.

\subsection{Mapeamento de Setores}

No método de mapeamento de setores, cada setor lógico do sistema de arquivos é diretamente mapeado para um setor físico correspondente na memória flash, resultando em uma tabela de mapeamento que possui uma linha para cada setor lógico. Se um bloco na memória flash é composto por quatro páginas, cada uma representando um setor, e houver 16 setores lógicos, a tabela de mapeamento terá 16 entradas. Quando o sistema precisa escrever dados em um setor lógico específico, ele consulta a tabela e escreve os dados no setor físico correspondente. Se o setor físico já estiver ocupado, o \gls{ftl} encontrará um novo setor físico vazio para armazenar os dados e atualizará a tabela de mapeamento. Caso todos os setores físicos estejam ocupados, o \gls{ftl} executará uma operação de limpeza: escolherá um bloco, copiará os dados válidos para outro bloco vazio, atualizará a tabela de mapeamento e apagará o bloco original, liberando espaço para futuras operações de escrita. Essa abordagem simples e direta garante a eficiência das operações de escrita, mas também requer limpeza e atualização constantes da tabela de mapeamento para manter a integridade dos dados e a eficiência do sistema, além de uma quantidade alta de \gls{ram} para manter a tabela de mapeamento \cite{BanPatent1995, FTLAlgorithms:Kwon2011}.

\subsection{Mapeamento de Blocos}

No método de mapeamento de blocos, o tamanho da linha da tabela de mapeamento lógico para físico corresponde ao número de blocos na memória flash. O número do bloco físico correspondente (do inglês, \gls{pbn}) é então recuperado da tabela de mapeamento de blocos. Em seguida, o \textit{offset} do bloco físico recuperado é determinado pelo resto da divisão. Por exemplo, se o número do bloco lógico (do inglês, \gls{lbn}) 2 é calculado dividindo 9 por 4, então PBN 2 é recuperado da tabela de mapeamento de blocos. A operação de escrita é realizada no segundo setor de PBN 2, pois o resto é 1 (9\%4). Muitos algoritmos que melhoram o desempenho usam o algoritmo de mapeamento de blocos como sua técnica básica de mapeamento, já que ele requer informações de mapeamento de tamanho reduzido \cite{Ban1999}. No entanto, se o sistema de arquivos emite muitos comandos de escrita com LSNs idênticos, isso levará a uma degradação severa de desempenho devido às operações de escrita e limpeza \cite{Shinohara1999, FTLAlgorithms:Kwon2011}.

\subsection{Mapeamento Híbrido}

No método híbrido de mapeamento, busca-se agregar as vantagens das soluções de mapeamento por setor e por bloco, mitigando as desvantagens associadas a cada uma delas, conforme discutido nas subseções anteriores \cite{FTLAlgorithms:Kwon2011}. Este método, conforme o nome sugere, utiliza inicialmente o mapeamento por bloco para determinar o bloco físico correspondente e, em seguida, emprega o mapeamento por setor para localizar um setor vazio dentro do bloco físico identificado. Por exemplo, quando o sistema de arquivos emite o comando ``w 9 A'', o \gls{ftl} calcula o número do bloco lógico (LBN 2) dividindo 9 por 4 e recupera o número do bloco físico (PBN 2) a partir da tabela de mapeamento por bloco. Posteriormente, busca-se um setor vazio na tabela de mapeamento por setor correspondente ao PBN. No exemplo citado, uma vez que o primeiro setor do PBN 2 está vazio, os dados são escritos neste setor. Essa técnica permite a escrita de dados em um \textit{offset} diferente do mapeamento por bloco, chamada de técnica \textit{out-of-place}, em contraste com a \textit{in-place} usada no mapeamento por bloco \cite{KimLee2002}. Após a escrita, a tabela de mapeamento por setor do bloco físico correspondente é atualizada, indicando que o \textit{offset} do setor físico 0 agora corresponde ao \textit{offset} do setor lógico 1 da tabela de mapeamento por setor do PBN 2, refletindo que os dados do LSN 9 estão escritos no primeiro setor do PBN 2. Quando dados precisam ser lidos da memória flash, o \gls{ftl} localiza o número do bloco físico através da tabela de mapeamento por bloco e encontra o \textit{offset} do setor físico correspondente na tabela de mapeamento por setor do PBN.

Os algoritmos \gls{ftl} avançados são projetados para melhorar o desempenho e a durabilidade dos \gls{ssd}s, utilizando técnicas mais complexas e sofisticadas para gerenciar as operações de escrita e leitura. Esses algoritmos podem ser classificados em duas categorias principais: algoritmos que melhoram o desempenho e algoritmos que aumentam a durabilidade.
Os algoritmos que melhoram o desempenho visam reduzir a latência de escrita e leitura, otimizando o uso da memória flash e minimizando o número de operações de apagamento. Esses algoritmos geralmente empregam técnicas de mapeamento de log, que utilizam blocos de log para armazenar dados temporariamente, reduzindo o número de operações de cópia e apagamento.

\subsection{Algoritmos Baseados em Log de Setores}

O algoritmo da Mitsubishi \cite{Shinohara1999} aloca \textit{log-sectors} dentro do mesmo bloco que contém os dados originais. O objetivo principal é reduzir o número de operações de limpeza causadas pela repetição de números de setores lógicos idênticos, melhorando o desempenho e reduzindo o desgaste (\textit{wear-levelling}). Baseado no mapeamento por bloco, ele requer pouca \textit{SRAM} e tem um baixo \textit{overhead} na construção da tabela de mapeamento. Nesse algoritmo, foram introduzidos os ``setores de espaço'' (\textit{space sectors}), que são setores vazios dentro de um bloco físico usados como \textit{buffer} para outros setores. Quando um setor físico está ocupado, o algoritmo procura um setor vazio na área de setores de espaço e escreve os dados ali. Durante uma leitura, os dados mais recentes são encontrados escaneando as áreas de sobra de baixo para cima. Quando não há mais setores vazios na área de setores de espaço, o algoritmo reorganiza o bloco físico copiando os setores válidos para um bloco livre, atualizando as informações de mapeamento e apagando o bloco antigo. Isso reduz o número de operações de limpeza, mas sacrifica a capacidade total da memória flash, pois cada bloco físico contém setores de espaço.

O M-Systems \cite{Ban1999} propôs os algoritmos \gls{ftl} conhecidos como \textit{ANAND} e \textit{FMAX}, que são exemplos do esquema de log baseado em setores, os quais alocam \textit{log-sectors} em blocos diferentes dos dados originais. Baseados no algoritmo de mapeamento por bloco, esses esquemas mapeiam um bloco lógico para dois blocos físicos, resultando em uma proporção de 1:2. Durante a operação de escrita, se um setor lógico já estiver preenchido, os dados são escritos em um ``bloco de substituição''. No algoritmo \textit{ANAND}, a sobrescrita é realizada no bloco de substituição onde os \textit{offsets} dos setores lógicos e físicos são idênticos (\textit{in-place}). Após três ocorrências do mesmo número de setor lógico, os dados válidos dos blocos de dados e de substituição são mesclados em um bloco livre, que se torna o novo bloco de dados, e os blocos antigos são apagados. Essa operação é chamada de ``\textit{merge operation}''. O \textit{FMAX}, por sua vez, reduz o número de operações de mesclagem utilizando todos os setores não usados do bloco de substituição antes de realizar a mesclagem, escrevendo dados de forma \textit{out-of-place}. Dessa forma, o \textit{FMAX} melhora a eficiência ao atrasar a necessidade de mesclagem até que todos os setores do bloco de substituição estejam preenchidos.

O AFTL, proposto por Wu e Kuo \cite{WuChin-Hsien2006}, é um gerenciador adaptativo de dois níveis para a camada de tradução de flash, cujo algoritmo de mapeamento é muito similar ao FMAX. Usando o ANAND como base, os autores identificaram a ineficiência no uso de todos os setores dentro do bloco de substituição. Como solução, o AFTL escreve as atualizações no bloco de substituição utilizando a técnica \textit{out-of-place}, além de empregar uma tabela de mapeamento de setores para o bloco de substituição. Dessa forma, o AFTL combina os algoritmos de mapeamento por bloco e por setor, sendo visto como um esquema de \textit{log-sector} que utiliza a técnica de mapeamento híbrido, aproveitando as vantagens de ambos os métodos para melhorar a eficiência e a durabilidade do sistema.

O RNFTL, proposto por \citet{WangYi2010}, tem um abordagem consciente de reutilização, cujo algoritmo de mapeamento é baseado principalmente no FMAX e ANAND. A principal motivação do RNFTL é melhorar a utilização do espaço durante a operação de \textit{merge}. Experimentos em tempo real mostraram que apenas 42\% do bloco original é ocupado com dados durante a operação de \textit{merge}. Para otimizar a utilização do espaço, o RNFTL preserva blocos originais de serem apagados se houver muitos setores vazios neles. O RNFTL mantém uma tabela de blocos preservados (\textit{dirty block table}), contendo os PBNs dos blocos preservados. Durante uma operação de \textit{merge}, o RNFTL verifica se a utilização do espaço do bloco original está abaixo de um limite predeterminado ``a''. Se estiver abaixo de ``a'', o PBN do bloco original é inserido na tabela de blocos preservados e seus setores vazios são reutilizados como \textit{log-sectors} para outros blocos originais. Caso contrário, a operação de \textit{merge} é realizada como no FMAX e ANAND. Em avaliações de desempenho, assumiu-se ``a'' como 20\%, resultando em uma redução significativa no número total de operações de apagamento; entretanto, o RNFTL ainda sofre com a exigência excessiva de \textit{log-sectors}, um problema comum ao esquema de \textit{log-sector}.

\subsection{Algoritmos Baseados em Log de Blocos}

O algoritmo BAST, proposto por Kim et al. \cite{BAST:JesungKim2002}, introduz um esquema de \textit{log-blocks} para reduzir o número de operações de apagamento, utilizando blocos de log como armazenamento temporário. Semelhante ao FMAX, BAST mapeia um bloco lógico para dois blocos físicos, mas difere ao usar menos de 0,3\% de \textit{log-blocks} para cobrir toda a memória flash, em vez de um bloco de \textit{buffer} para cada bloco de dados. O BAST mantém informações básicas de mapeamento em uma tabela de mapeamento de blocos e uma tabela separada para os \textit{log-blocks}. Durante uma operação de escrita, se o setor designado já estiver ocupado, os dados são escritos no \textit{log-block} correspondente, e as operações subsequentes preenchem os \textit{log-blocks} de forma sequencial. Quando todos os \textit{log-blocks} estão cheios, uma operação de \textit{merge} é realizada, copiando os dados atualizados do \textit{log-block} e do bloco de dados associado para um bloco livre, atualizando a tabela de mapeamento e apagando os blocos antigos. Uma otimização chamada ``operação de troca''' pode ser aplicada quando todos os setores de um \textit{log-block} são escritos sequencialmente, permitindo que o \textit{log-block} se torne o novo bloco de dados com apenas uma operação de apagamento.

\citet{FASTFTL:Lee2007} observaram que a baixa utilização de espaço pode ocorrer devido ao nivelamento por bloco, já que um \textit{log-block} dedicado a um bloco de dados pode ter muitos setores não utilizados, forçando uma operação de \textit{merge}. Como solução, Lee et al. propuseram a tradução de setores totalmente associativa (FAST) \cite{FASTFTL:Lee2007}, onde os \textit{log-blocks} são divididos em dois grupos: \textit{SW log-blocks} para escritas sequenciais e \textit{RW log-blocks} para escritas aleatórias. No FAST, um \textit{log-block SW} é utilizado apenas para operações de troca, enquanto os \textit{log-blocks RW} funcionam como um \textit{buffer} compartilhado, preenchendo dados de forma sequencial. Quando um setor em um bloco de dados já está ocupado, o FAST escreve os dados no \textit{log-block}. Se o setor estiver sendo preenchido sequencialmente, os dados são escritos no \textit{log-block SW}; caso contrário, são escritos no primeiro setor vazio do \textit{log-block RW}. Quando todos os setores dos \textit{log-blocks RW} estão preenchidos, uma operação de \textit{merge} é realizada, copiando os dados válidos para blocos livres e apagando os \textit{log-blocks} e os blocos de dados associados. A operação de \textit{merge} no FAST pode exigir uma cadeia de operações de apagamento em todos os blocos de dados associados aos \textit{log-blocks RW}, enquanto no caso do \textit{log-block SW}, uma operação de troca é realizada de forma similar ao BAST.

O algoritmo EAST, proposto por \citet{Kwon2008}, aborda as limitações do FAST em termos de baixa utilização de espaço e alto custo de operações de \textit{merge}. Para melhorar a utilização do espaço, EAST utiliza técnicas \textit{in-place} e \textit{out-of-place} dentro dos blocos de dados, garantindo a utilização completa dos setores vazios antes de qualquer \textit{merge}. Para reduzir o custo das operações de \textit{merge}, EAST associa múltiplos \textit{log-blocks} a um único bloco de dados, semelhante ao BAST, mas com a capacidade de cada bloco de dados ter vários \textit{log-blocks}. O estado padrão dos blocos é \textit{in-place}, mudando para \textit{out-of-place} apenas quando ocorre uma sobrescrita. Blocos no estado \textit{out-of-place} podem receber \textit{log-blocks} adicionais até um limite calculado para garantir que o tempo de leitura não exceda o tempo de apagamento. Quando este limite é atingido e não há espaço disponível, uma operação de \textit{merge} é realizada, copiando os dados válidos para blocos livres e apagando os blocos antigos. Esta abordagem aumenta a eficiência da utilização de espaço e reduz o número de operações de \textit{merge} necessárias, melhorando o desempenho geral.

O algoritmo LAST, ou \textit{Locality-Aware Sector Translation}, proposto por Lee et al. \cite{LASTFTL:Lee2008}, busca superar as limitações do FAST ao implementar uma política de detecção de localidade e uma divisão regional para blocos de log aleatórios. Esta política classifica os dados de cada comando de escrita como quentes ou frios com base no tamanho da solicitação, com dados quentes geralmente tendo tamanhos de solicitação menores. Os dados classificados como frios são escritos em blocos de log sequenciais ou diretamente em blocos de dados. A divisão regional divide os blocos de log aleatórios em regiões quentes e frias, reduzindo o custo de operações de \textit{merge}, particularmente para dados quentes que são atualizados frequentemente. Embora LAST reduza o número de operações de \textit{merge} por meio dessa abordagem, Lee et al. reconhecem que o detector de localidade falha em identificar escritas sequenciais eficientemente, especialmente quando o volume de trabalho envolve muitas pequenas escritas sequenciais, limitando assim a utilidade do algoritmo em cenários de carga de trabalho dinâmica.

Os algoritmos de \gls{ftl} baseados em conjunto de blocos surgiram como solução para as dificuldades de manter todas as informações de mapeamento na \gls{ram} em memórias flash de blocos grandes. Hsieh et al. \cite{ConfigurableFTL:2008} propuseram o CNFTL, que permite ajustar a tabela de mapeamento de setor para bloco conforme as características da memória, introduzindo o conceito de ``\textit{block-set}''. Nesse esquema, \textit{N} blocos de dados e \textit{M} \textit{log-blocks} são agrupados em um conjunto, com \textit{M} variando conforme as operações de \textit{merge}. Park et al. desenvolveram o SAST \cite{reconfigurableFTL2008}, que usa uma tabela de mapeamento de \textit{block-set} e mapeamento de páginas para separar dados quentes e frios. Já o \textit{Superblock} \gls{ftl} \cite{SuperblockFTL:2010} é semelhante ao SAST, mas registra informações de mapeamento na área de sobra de cada setor, economizando \gls{ram}, mas potencialmente aumentando as operações parciais de leitura e escrita.

Os algoritmos de nivelamento de desgaste baseados em \gls{ecn} monitoram e registram o número de ciclos de apagamento \gls{ecn} de cada bloco em memórias \textit{flash} para gerenciar o desgaste de maneira uniforme. O método \textit{dual pool} \cite{Assar1995}, por exemplo, distingue blocos com base na frequência de uso, armazenando-os em tabelas de blocos quentes e frios. Essas tabelas são atualizadas com base no \gls{ecn}, permitindo ao sistema realizar o nivelamento de desgaste redistribuindo operações entre blocos para estender a vida útil da memória. O processo se ajusta dinamicamente, reclassificando blocos como quentes ou frios conforme a diferença entre o \gls{ecn} de cada bloco e a média, otimizando o desempenho e minimizando a degradação.

Os algoritmos de nivelamento de desgaste baseados em escritas monitoram a frequência de gravações nos blocos para distribuir o desgaste uniformemente em memórias \textit{flash}. Achiwa \cite{Han2000} descreve um algoritmo que registra a contagem de gravações em \textit{SRAM}, reorganizando os dados para maximizar a durabilidade dos blocos. Chang \cite{Chang2006}, por sua vez, propõe uma versão desses algoritmos onde as tabelas de blocos acessados frequentemente e raramente podem ser redimensionadas conforme a mudança nos padrões de gravação, adaptando-se dinamicamente às condições de uso. Além disso, os algoritmos baseados em grupos, como descritos por Lofgren \cite{Wells1994} e Conley \cite{Conley2002}, agrupam múltiplos blocos para reduzir a complexidade e o espaço necessário para gerenciar o nivelamento de desgaste. Por exemplo, Lofgren organiza blocos em "bancos", calculando médias de desgaste para facilitar trocas entre grupos quentes e frios, enquanto Conley divide a memória em zonas para equilibrar blocos livres e ocupados, lidando com discrepâncias causadas por defeitos ou uso intensivo.

Os algoritmos de nivelamento de desgaste baseados em grupos organizam blocos físicos de memória flash em unidades maiores, chamadas de grupos ou zonas, para otimizar a gestão do desgaste e reduzir os requisitos de \textit{SRAM}. Nestes algoritmos, múltiplos blocos são agrupados em uma única unidade física, diminuindo significativamente o número de entradas necessárias nas tabelas de mapeamento, como ilustrado pela redução para 1,6 \gls{kb} de \textit{SRAM} necessários para a tabela de mapeamento de grupo em um contexto de 256 \gls{mb} de memória \cite{Lofgren2005}. Além disso, esses algoritmos utilizam a média do número de ciclos de apagamento de cada grupo para facilitar o equilíbrio entre blocos mais e menos usados. Lofgren define unidades chamadas 'bancos', que consistem em três a quatro blocos, e realiza trocas entre grupos quentes e frios baseando-se em um limite de desvio das médias \cite{Lofgren2005}. Conley expande essa ideia gerenciando a memória em zonas ainda maiores, onde a memória é dividida em várias zonas para equilibrar o número de blocos livres e utilizados, ajustando-se dinamicamente para compensar defeitos de fábrica ou desgastes desiguais \cite{Conley2002}.

\section{Otimização da Coleta de Lixo em FTLs}
\label{DeallocFTL:KimJoontae2023}

\citet{DeallocFTL:KimJoontae2023} propuseram o algoritmo \textit{DeallocFTL} com o objetivo de aprimorar a performance dos \glspl{ftl} tradicionais, especialmente nas operações de coleta de lixo (\textit{garbage collection}). Esse algoritmo busca melhorar o gerenciamento de arquivos temporários nos blocos dos \glspl{ssd}. Arquivos temporários são criados para armazenar dados de forma provisória durante a execução de programas ou processos, sendo úteis para guardar informações que não precisam ser mantidas permanentemente, como caches, \textit{logs} temporários ou dados intermediários.

A operação de coleta de lixo está intimamente relacionada aos arquivos temporários, pois é responsável por gerenciar a memória e liberar recursos não utilizados, incluindo arquivos temporários que não são mais necessários. O \textit{garbage collector} identifica e remove esses arquivos, otimizando o uso de recursos e garantindo que o sistema permaneça eficiente e sem desperdícios de armazenamento. No entanto, as operações realizadas pelo \textit{garbage collector} geram \textit{overhead}, conhecido como \gls{waf}. Quando um dado é deletado, o controlador do \gls{ssd} mantém a página daquele arquivo como válida, o que faz com que páginas inúteis sejam copiadas durante o processo de coleta de lixo, aumentando o \gls{waf}. Sistemas operacionais como Windows 10 e Linux utilizam o comando \textit{trim}, que indica ao \gls{ssd} quais blocos de dados não são mais necessários, reduzindo a quantidade de arquivos a serem copiados durante a coleta de lixo e melhorando o desempenho do sistema. Todavia, o uso excessivo desse comando pode gerar \textit{overhead} de \textit{I/O}, diminuindo drasticamente a performance do \gls{ssd}.

O \textit{DeallocFTL} é caracterizado pelo uso restrito de arquivos temporários, onde, uma vez acessados, o bloco do \gls{ssd} que os armazena é desalocado. Dessa forma, o \textit{DeallocFTL} evita que dados inúteis permaneçam armazenados em arquivos temporários, reduzindo o custo das operações de coleta de lixo. Além disso, o algoritmo não depende do sistema operacional enviar um comando \textit{trim} para desalocar dados inúteis, visto que esses são desalocados assim que são lidos. Os resultados apresentados demonstram uma melhoria de até 2x no desempenho do \textit{DeallocFTL} em operações do tipo \textit{hash join} e de até 8x em operações de \textit{sort-merge-join}.

\section{Otimização do uso de Páginas em SSDs TLC}
\label{PA-SSD:2018}

\cite{PA-SSD:2018} propôs o algoritmo \textit{Page-Type Aware} (\textit{PA-SSD}) para \gls{ssd}s \gls{tlc}, visando mitigar o impacto das altas latências associadas às páginas \gls{MSB} em comparação com as páginas \gls{LSB} e \gls{CSB}. Em \gls{ssd}s \gls{tlc}, uma solicitação de escrita maior que uma página é dividida em \textit{sub-requests} do tamanho de uma página, que são alocadas para processamento paralelo. O tempo de resposta da solicitação de escrita é determinado pela sub-solicitação mais lenta, resultando em tempos de resposta mais longos quando as sub-solicitações são servidas por páginas \gls{MSB}.

Para mitigar esse impacto, o algoritmo \textit{PA-SSD} minimiza as escritas dominadas por \gls{MSB} e maximiza as dominadas por \gls{LSB}, melhorando o desempenho de escrita dos \gls{ssd}s \gls{tlc}. Esta estratégia coordenada aloca páginas do mesmo tipo para as \textit{sub-requests} de uma mesma solicitação de escrita, controlando proativamente os tipos de páginas usadas.

O algoritmo \textit{PA-SSD} implementa duas principais inovações. Primeiro, a interface do host atribui proativamente um tipo de página para cada solicitação de escrita do usuário, utilizando sete esquemas específicos: \textit{Uniformly Specification} (US), \textit{Host-Guided Specification} (HGS), \textit{LSB-First Specification} (LFS), \textit{Size-based Specification} (SBS), \textit{Queue-Depth-based Specification} (QDS), \textit{Write-Buffer-based Specification} (WBS) e \textit{Utilization-based Specification} (UBS). Cada esquema possui uma abordagem distinta para otimizar o desempenho de escrita. Segundo, o \textit{PA-SSD} aloca \textit{IDs} de bloco e \textit{IDs} de página para as sub-solicitações de acordo com os tipos de página atribuídos, utilizando a primitiva \textit{pa-BLAlloc} redesenhada. Após a determinação do tipo de página, esse tipo é herdado pelas sub-solicitações durante o processo de alocação, contrastando com a estratégia de alocação cega dos \gls{ssd}s \gls{tlc} convencionais. Além disso, o \textit{PA-SSD} oferece múltiplas páginas candidatas com diferentes tipos dentro de cada plano, melhorando a eficiência e o desempenho da escrita.

O algoritmo \textit{PA-SSD} apresentou diversas melhorias significativas no desempenho dos \glspl{ssd} \gls{tlc}. Em termos de tempo de resposta médio, o \textit{PA-SSD} reduziu consideravelmente os tempos de escrita e leitura, aumentando a eficiência geral de acesso aos dados. O desempenho de escrita ao longo do tempo se mostrou estável, mantendo a velocidade mesmo com uso contínuo. Em cenários de uso prolongado, o \textit{PA-SSD} manteve um alto desempenho, assegurando operação confiável e eficiente. Conforme \citet{DeallocFTL:KimJoontae2023}, o \textit{PA-SSD} elimina a ineficiência de escrita dos designs convencionais, utilizando um design consciente do tipo de página e atribuindo tipos específicos para sub-solicitações de escrita. Com sete esquemas propostos de especificação de tipo de página e a primitiva \textit{BLAlloc} redesenhada, o \textit{PA-SSD}, implementado e avaliado com o \textit{SSD-Sim}, mostrou melhorias de 2,4 vezes em escrita e 1,5 vezes em leitura em comparação ao design convencional.

%%%% Capítulo 4 - PROPOSTA

\chapter{Proposta}
\label{cap:proposta}

% Delimitação do Assunto
Este estudo limita-se à análise dos três principais tipos de algoritmos \gls{ftl}: \textit{page-mapping}, \textit{block-mapping} e \textit{hybrid-mapping}. A pesquisa focará em como essas estratégias afetam a durabilidade das células de memória, a eficiência do armazenamento, e o desempenho global dos dispositivos em cenários de uso variados.

% Formulação de Hipóteses
As hipóteses deste trabalho estão definidas da seguinte forma:
\begin{itemize}
    \item H1: Algoritmos de \textit{page-mapping} oferecem menos eficiência no uso do espaço e maior desempenho em cenários de uso intensivo de dados.
    \item H2: Algoritmos de \textit{block-mapping} aumentam a eficiência no uso do espaço, porém apresentam \textit{overhead} computacional afetando o desempenho.
    \item H3: Algoritmos \textit{hybrid-mapping} apresentam uma balanceada combinação de eficiência, desempenho e durabilidade, adaptando-se dinamicamente a diferentes padrões de acesso aos dados.
\end{itemize}

% Objetivos
\section{Objetivos}
\subsection{Objetivo Geral}
Investigar qual algoritmo \gls{ftl} proporciona a melhor performance, durabilidade e eficiência em diferentes cenários de uso de \gls{ssd}s.

\subsection{Objetivos Específicos}
\begin{itemize}
    \item Analisar a eficiência no uso do espaço e a performance de cada algoritmo \gls{ftl}.
    \item Avaliar o impacto de cada algoritmo na durabilidade das células de memória flash.
    \item Comparar a eficiência energética dos algoritmos \gls{ftl} em cenários de uso real.
\end{itemize}

%%%% CAPÍTULO 5 - METODOLOGIA

\chapter{Metodologia}
\label{cap:metodologia}

Este capítulo detalha a metodologia empregada para a realização da pesquisa, descrevendo os métodos e procedimentos utilizados para alcançar os objetivos propostos. A metodologia se estrutura em duas etapas principais: revisão bibliográfica e análise comparativa de algoritmos \gls{ftl}.

\section{Revisão Bibliográfica}
\label{sec:revisao_bibliografica}

A primeira etapa da pesquisa consiste em uma revisão bibliográfica abrangente sobre algoritmos \gls{ftl}, com foco nos três principais tipos: \textit{page-mapping}, \textit{block-mapping} e \textit{hybrid-mapping}. A revisão bibliográfica visa:

\begin{itemize}
    \item Compreender os princípios de funcionamento de cada algoritmo \gls{ftl}, incluindo suas vantagens e desvantagens.
    \item Identificar as principais métricas de avaliação de desempenho, durabilidade e eficiência energética para algoritmos \gls{ftl}.
    \item Analisar estudos anteriores que compararam diferentes algoritmos \gls{ftl}, identificando as metodologias e resultados obtidos.
\end{itemize}

A revisão bibliográfica será realizada através da consulta a bases de dados acadêmicas como \textit{IEEE Xplore} e \textit{ACM Digital Library}. Serão utilizados termos de pesquisa relevantes como ``\textit{\gls{ftl}}'', ``\textit{\gls{ftl} algorithms}'' e ``\textit{flash memory management}''. Além de artigos científicos, serão consultados livros, relatórios técnicos e patentes relacionadas ao tema.

\section{Análise Comparativa de Algoritmos FTL}
\label{sec:analise_comparativa}

Após a revisão bibliográfica, a segunda etapa da pesquisa consiste em uma análise comparativa dos três tipos de algoritmos \gls{ftl}: \textit{page-mapping}, \textit{block-mapping} e \textit{hybrid-mapping}. A análise comparativa visa:

\begin{itemize}
    \item Comparar a eficiência no uso do espaço de cada algoritmo, considerando a fragmentação e o \textit{overhead} de gerenciamento.
    \item Analisar a durabilidade de cada algoritmo, considerando o desgaste das células de memória flash e a capacidade de nivelamento de desgaste.
    \item Avaliar a eficiência energética de cada algoritmo, considerando o desempenho de operações de leitura, escrita e limpeza.
\end{itemize}

A análise comparativa será realizada através de características observadas nas implementações dos algoritmos \gls{ftl} estudados conforme os aspectos mencionados anteriormente.

%%%% CAPÍTULO 6 - RESULTADOS

\chapter{Resultados}
\label{cap:resultados}

Este capítulo apresenta os resultados da análise comparativa dos algoritmos \gls{ftl} estudados, com base na revisão bibliográfica realizada nos Capítulos \ref{cap:referencialTeorico} e \ref{cap:trabalhosRelacionados}. A análise se concentra em quatro aspectos principais: eficiência no uso do espaço, durabilidade, desempenho e eficiência energética. Para facilitar a compreensão, os algoritmos \gls{ftl} foram categorizados em três grupos: mapeamento por setor/página, mapeamento por bloco e mapeamento híbrido, conforme a Tabela \ref{tab:classificacao_algoritmos}.

\begin{table}[ht]
\centering
\caption{Classificação dos Algoritmos FTL}
\label{tab:classificacao_algoritmos}
\begin{tabularx}{\textwidth}{|X|X|}
\hline
\textbf{Categoria} & \textbf{Algoritmos} \\
\hline
Mapeamento por Setor/Página & ANAND \cite{Ban1999}, FMAX \cite{Ban1999}, AFTL \cite{WuChin-Hsien2006}, RNFTL \cite{WangYi2010},  \textit{Page-Mapping} \cite{Kawaguchi:1995}, DeallocFTL \cite{DeallocFTL:KimJoontae2023} \\
\hline
Mapeamento por Bloco & \textit{Block-Mapping} \cite{Shinohara1999} \\
\hline
Mapeamento Híbrido & BAST \cite{BAST:JesungKim2002}, FAST \cite{FASTFTL:Lee2007}, LAST \cite{LASTFTL:Lee2008}, CNFTL \cite{ConfigurableFTL:2008}, SAST \cite{reconfigurableFTL2008}, \textit{Superblock} \cite{SuperblockFTL:2010}, EAST \cite{Kwon2008}, PA-SSD \cite{PA-SSD:2018} \\
\hline
\end{tabularx}
\end{table}

\section{Eficiência no Uso do Espaço}
A eficiência no uso do espaço é crucial para a performance dos SSDs, pois influencia diretamente a capacidade de armazenamento e a velocidade de acesso aos dados. A fragmentação, tanto interna quanto externa, impacta negativamente a eficiência, pois aumenta o tempo necessário para encontrar e acessar os dados.

\subsection{Mapeamento por Setor/Página}
Os algoritmos de mapeamento por setor/página, como ANAND, FMAX, AFTL, RNFTL, \textit{Page-Mapping} e DeallocFTL, geralmente apresentam baixa eficiência no uso do espaço. Isso se deve à necessidade de uma grande tabela de mapeamento para armazenar a relação entre os setores lógicos e físicos, o que consome uma quantidade significativa de memória. Além disso, a necessidade de operações frequentes de limpeza para liberar espaço pode aumentar a fragmentação interna, reduzindo a eficiência geral.

ANAND e FMAX \cite{Ban1999} são algoritmos que utilizam um esquema de log baseado em setores, onde os dados são escritos em blocos de log separados dos blocos de dados originais. Essa abordagem pode levar à fragmentação externa, pois os dados podem ser dispersos em diferentes blocos. AFTL \cite{WuChin-Hsien2006} é uma variação do FMAX que utiliza uma tabela de mapeamento de setores para o bloco de log, o que pode melhorar a eficiência no uso do espaço. RNFTL \cite{WangYi2010} é um algoritmo que busca otimizar a utilização do espaço durante a operação de merge, preservando blocos originais com muitos setores vazios. \textit{Page-Mapping} \cite{Kawaguchi:1995} é um algoritmo que mapeia cada página lógica para uma página física, o que requer uma grande tabela de mapeamento e pode levar à fragmentação interna. DeallocFTL \cite{DeallocFTL:KimJoontae2023} é um algoritmo que busca melhorar a performance dos \glspl{ftl} tradicionais, especialmente nas operações de coleta de lixo (\textit{garbage collection}), através do uso restrito de arquivos temporários.

\subsection{Mapeamento por Bloco}
O mapeamento por bloco, como apresentado em \textit{Block-Mapping}, utiliza uma tabela de mapeamento menor em comparação com o mapeamento por setor/página, economizando espaço de memória. No entanto, a necessidade de copiar dados para um novo bloco ao realizar uma operação de escrita parcial pode gerar fragmentação externa, impactando a eficiência do uso do espaço.

\textit{Block-Mapping} \cite{Shinohara1999} é um algoritmo que mapeia blocos lógicos para blocos físicos, o que pode levar à fragmentação externa, pois os dados podem ser dispersos em diferentes blocos.

\subsection{Mapeamento Híbrido}
Os algoritmos de mapeamento híbrido, como BAST, FAST, LAST, CNFTL, SAST, \textit{Superblock}, EAST e PA-SSD, combinam as vantagens do mapeamento por setor/página e por bloco, buscando um equilíbrio entre eficiência e desempenho. Essa abordagem utiliza uma tabela de mapeamento de tamanho intermediário, com um \textit{overhead} computacional variável. A eficiência no uso do espaço depende da implementação específica do algoritmo, mas geralmente apresenta um bom desempenho em termos de fragmentação.

BAST \cite{BAST:JesungKim2002} é um algoritmo que utiliza um esquema de log baseado em blocos, onde os dados são escritos em blocos de log separados dos blocos de dados originais. Essa abordagem pode levar à fragmentação externa, mas o BAST utiliza uma tabela de mapeamento de blocos para gerenciar os blocos de log, o que pode melhorar a eficiência no uso do espaço. FAST \cite{FASTFTL:Lee2007} é um algoritmo que utiliza blocos de log separados para escritas sequenciais e aleatórias, o que pode melhorar a eficiência no uso do espaço, pois os dados são escritos em blocos de log dedicados. LAST \cite{LASTFTL:Lee2008} é um algoritmo que utiliza uma política de detecção de localidade para otimizar a utilização do espaço, escrevendo dados quentes em blocos de log dedicados. CNFTL \cite{ConfigurableFTL:2008} é um algoritmo que utiliza conjuntos de blocos para gerenciar o mapeamento, o que pode melhorar a eficiência no uso do espaço, pois os dados são agrupados em conjuntos de blocos. SAST \cite{reconfigurableFTL2008} é um algoritmo que utiliza uma tabela de mapeamento de conjuntos de blocos e mapeamento de páginas para separar dados quentes e frios, o que pode melhorar a eficiência no uso do espaço, pois os dados quentes são armazenados em blocos dedicados. \textit{Superblock} \cite{SuperblockFTL:2010} é um algoritmo que utiliza uma tabela de mapeamento de conjuntos de blocos e armazena informações de mapeamento na área de sobra de cada setor, o que pode melhorar a eficiência no uso do espaço, pois a tabela de mapeamento é armazenada de forma compacta. EAST \cite{Kwon2008} é um algoritmo que utiliza blocos de log dedicados para cada bloco de dados, o que pode melhorar a eficiência no uso do espaço, pois os dados são escritos em blocos de log dedicados. PA-SSD \cite{PA-SSD:2018} é um algoritmo que visa mitigar o impacto das altas latências associadas às páginas \gls{MSB} em comparação com as páginas \gls{LSB} e \gls{CSB} em \gls{ssd}s \gls{tlc}.

\section{Durabilidade}
A durabilidade dos SSDs é um fator crítico, pois determina a vida útil do dispositivo. O desgaste das células de memória flash é um processo natural que ocorre com o tempo, e o nivelamento de desgaste é crucial para distribuir uniformemente as operações de escrita e prolongar a vida útil do dispositivo.

\subsection{Mapeamento por Setor/Página}
Os algoritmos de mapeamento por setor/página, devido à sua natureza simples, podem resultar em um desgaste desigual das células de memória flash, pois as operações de escrita são direcionadas para os mesmos setores. Isso pode levar a uma redução da vida útil do dispositivo.

\subsection{Mapeamento por Bloco}
O mapeamento por bloco, ao realizar operações de cópia para um novo bloco, pode contribuir para um desgaste mais uniforme das células de memória flash. No entanto, a fragmentação externa pode impactar a eficiência do nivelamento de desgaste, reduzindo a durabilidade do dispositivo.

\subsection{Mapeamento Híbrido}
Os algoritmos de mapeamento híbrido, ao combinar as características do mapeamento por setor/página e por bloco, oferecem uma abordagem mais flexível para o gerenciamento de desgaste. A capacidade de adaptar-se dinamicamente a diferentes padrões de acesso aos dados permite um nivelamento de desgaste mais eficiente, prolongando a vida útil do dispositivo.

\section{Desempenho}
O desempenho dos SSDs é um fator crucial para diversas aplicações, pois influencia diretamente a velocidade de acesso aos dados e a capacidade de processamento. A latência de leitura e escrita, bem como a velocidade de transferência de dados, são métricas importantes para avaliar o desempenho.

\subsection{Mapeamento por Setor/Página}
Os algoritmos de mapeamento por setor/página, devido à sua simplicidade, geralmente apresentam um desempenho regular em termos de latência de leitura e escrita. No entanto, a necessidade de operações frequentes de limpeza pode impactar negativamente o desempenho, especialmente em cenários de uso intensivo de dados.

\subsection{Mapeamento por Bloco}
O mapeamento por bloco, ao reduzir o tamanho da tabela de mapeamento, pode melhorar o desempenho em termos de latência de leitura. No entanto, a necessidade de copiar dados para um novo bloco ao realizar uma operação de escrita parcial pode aumentar a latência de escrita, impactando o desempenho geral.

\subsection{Mapeamento Híbrido}
Os algoritmos de mapeamento híbrido, ao combinar as vantagens do mapeamento por setor/página e por bloco, geralmente apresentam um desempenho superior em comparação com as outras abordagens. A capacidade de adaptar-se dinamicamente a diferentes padrões de acesso aos dados permite um desempenho otimizado em diversos cenários de uso.

\section{Eficiência Energética}
A eficiência energética é um fator cada vez mais importante para os SSDs, especialmente em dispositivos móveis e centros de dados. O consumo de energia durante as operações de leitura, escrita e limpeza impacta diretamente a vida útil da bateria e o consumo de energia geral.

\subsection{Mapeamento por Setor/Página}
Os algoritmos de mapeamento por setor/página, devido à necessidade de operações frequentes de limpeza, podem apresentar um consumo de energia relativamente alto. A limpeza envolve a cópia de dados para um novo bloco, o que exige operações adicionais de leitura e escrita, aumentando o consumo de energia.

\subsection{Mapeamento por Bloco}
O mapeamento por bloco, ao reduzir o número de operações de limpeza, pode apresentar um consumo de energia mais baixo em comparação com o mapeamento por setor/página. No entanto, a necessidade de copiar dados para um novo bloco ao realizar uma escrita parcial pode aumentar o consumo de energia.

\subsection{Mapeamento Híbrido}
Os algoritmos de mapeamento híbrido, ao buscar um equilíbrio entre eficiência e desempenho, geralmente apresentam um consumo de energia moderado. A capacidade de adaptar-se dinamicamente a diferentes padrões de acesso aos dados permite otimizar o consumo de energia em diversos cenários de uso.

\section{Comparação dos Algoritmos}
A Tabela \ref{tab:comparacao_algoritmos} apresenta uma comparação dos algoritmos \gls{ftl} estudados, considerando quatro aspectos principais: Eficiência no Uso do Espaço, Durabilidade, Desempenho e Eficiência Energética. Cada valor na tabela é justificado com base na análise da literatura e nas características de cada algoritmo.

\begin{table}[ht]
\centering
\caption{Comparação dos Algoritmos FTL}
\label{tab:comparacao_algoritmos}
\begin{tabularx}{\textwidth}{|X|X|X|X|X|}
\hline
\textbf{Algoritmo} & \textbf{Eficiência no Uso do Espaço} & \textbf{Durabilidade} & \textbf{Desempenho} & \textbf{Eficiência Energética} \\
\hline
ANAND & Baixa & Baixa & Regular & Alta \\
\hline
FMAX & Baixa & Baixa & Regular & Alta \\
\hline
AFTL & Baixa & Baixa & Regular & Alta \\
\hline
RNFTL & Baixa & Baixa & Regular & Alta \\
\hline
\textit{Page-Mapping} & Baixa & Baixa & Regular & Alta \\
\hline
DeallocFTL & Baixa & Baixa & Alta & Alta \\
\hline
\textit{Block-Mapping} & Média & Média & Melhorado & Média \\
\hline
BAST & Alta & Alta & Alta & Média \\
\hline
FAST & Alta & Alta & Alta & Baixa \\
\hline
LAST & Alta & Alta & Alta & Baixa \\
\hline
CNFTL & Alta & Alta & Alta & Média \\
\hline
SAST & Alta & Alta & Alta & Média \\
\hline
\textit{Superblock} & Alta & Alta & Alta & Média \\
\hline
EAST & Alta & Alta & Alta & Baixa \\
\hline
PA-SSD & Alta & Alta & Alta & Baixa \\
\hline
\end{tabularx}
\end{table}

\subsection{Eficiência no Uso do Espaço}
\begin{itemize}
    \item \textit{ANAND, FMAX, AFTL, RNFTL, Page-Mapping, DeallocFTL}: Baixa. Esses algoritmos, principalmente os baseados em log de setores, tendem a ter baixa eficiência no uso do espaço devido à necessidade de tabelas de mapeamento grandes e operações frequentes de limpeza.
    \item \textit{Block-Mapping}: Média. O mapeamento por bloco utiliza uma tabela de mapeamento menor, economizando espaço. No entanto, a fragmentação externa pode ocorrer devido à necessidade de copiar dados para um novo bloco ao realizar uma escrita parcial.
    \item \textit{BAST, FAST, LAST, CNFTL, SAST, Superblock, EAST, PA-SSD}: Alta. Os algoritmos híbridos, ao combinar as vantagens do mapeamento por setor e por bloco, geralmente apresentam boa eficiência no uso do espaço. Eles utilizam tabelas de mapeamento de tamanho intermediário e implementam estratégias para minimizar a fragmentação.
\end{itemize}

\subsection{Durabilidade}
\begin{itemize}
    \item \textit{ANAND, FMAX, AFTL, RNFTL, Page-Mapping, DeallocFTL}: Baixa. Esses algoritmos, devido à sua natureza simples, podem resultar em desgaste desigual das células de memória flash, levando a uma redução da vida útil do dispositivo.
    \item \textit{Block-Mapping}: Média. O mapeamento por bloco pode contribuir para um desgaste mais uniforme, mas a fragmentação externa pode impactar a eficiência do nivelamento de desgaste.
    \item \textit{BAST, FAST, LAST, CNFTL, SAST, Superblock, EAST, PA-SSD}: Alta. Os algoritmos híbridos, ao combinar as características do mapeamento por setor/página e por bloco, oferecem uma abordagem mais flexível para o gerenciamento de desgaste. A capacidade de adaptar-se dinamicamente a diferentes padrões de acesso aos dados permite um nivelamento de desgaste mais eficiente, prolongando a vida útil do dispositivo.
\end{itemize}

\subsection{Desempenho}
\begin{itemize}
    \item \textit{ANAND, FMAX, AFTL, RNFTL, Page-Mapping}: Regular. Esses algoritmos, devido à sua simplicidade, geralmente apresentam um desempenho regular em termos de latência de leitura e escrita. No entanto, a necessidade de operações frequentes de limpeza pode impactar negativamente o desempenho, especialmente em cenários de uso intensivo de dados.
    \item \textit{Block-Mapping}: Melhorado. O mapeamento por bloco, ao reduzir o tamanho da tabela de mapeamento, pode melhorar o desempenho em termos de latência de leitura. No entanto, a necessidade de copiar dados para um novo bloco ao realizar uma escrita parcial pode aumentar a latência de escrita, impactando o desempenho geral.
    \item \textit{BAST, FAST, LAST, CNFTL, SAST, Superblock, EAST, PA-SSD}: Alta. Os algoritmos híbridos, ao combinar as vantagens do mapeamento por setor/página e por bloco, geralmente apresentam um desempenho superior em comparação com as outras abordagens. A capacidade de adaptar-se dinamicamente a diferentes padrões de acesso aos dados permite um desempenho otimizado em diversos cenários de uso.
\end{itemize}

\subsection{Eficiência Energética}
\begin{itemize}

    \item \textit{ANAND, FMAX, AFTL, RNFTL, Page-Mapping, DeallocFTL}: Alta. Esses algoritmos, devido à necessidade de operações frequentes de limpeza, podem apresentar um consumo de energia relativamente alto. A limpeza envolve a cópia de dados para um novo bloco, o que exige operações adicionais de leitura e escrita, aumentando o consumo de energia.

    \item \textit{Block-Mapping}: Média. O mapeamento por bloco, ao reduzir o número de operações de limpeza, pode apresentar um consumo de energia mais baixo em comparação com o mapeamento por setor/página. No entanto, a necessidade de copiar dados para um novo bloco ao realizar uma escrita parcial pode aumentar o consumo de energia.

    \item \textit{BAST, FAST, LAST, CNFTL, SAST, Superblock, EAST, PA-SSD}: Baixa. Os algoritmos híbridos, ao buscar um equilíbrio entre eficiência e desempenho, geralmente apresentam um consumo de energia moderado. A capacidade de adaptar-se dinamicamente a diferentes padrões de acesso aos dados permite otimizar o consumo de energia em diversos cenários de uso.

\end{itemize}

\section{Discussão das Hipóteses}

Este capítulo apresenta a análise das hipóteses levantadas no início da pesquisa, com base nos resultados obtidos através da revisão bibliográfica e da análise comparativa dos algoritmos \gls{ftl}.

\textbf{Hipótese 1:} Algoritmos de \textit{page-mapping} oferecem menos eficiência no uso do espaço e maior desempenho em cenários de uso intensivo de dados.

\textbf{Resposta:} A hipótese 1 se confirma parcialmente. Os algoritmos de \textit{page-mapping} de fato apresentam menor eficiência no uso do espaço, devido à necessidade de uma grande tabela de mapeamento, como observado em trabalhos como \cite{EnergyEfficiencySSD:Park2011} e \cite{FTLAlgorithms:Kwon2011}. No entanto, o desempenho em cenários de uso intensivo de dados não é necessariamente superior. A necessidade de operações frequentes de limpeza para liberar espaço pode impactar negativamente o desempenho, especialmente em cenários de escrita aleatória.

\textbf{Hipótese 2:} Algoritmos de \textit{block-mapping} aumentam a eficiência no uso do espaço, porém apresentam \textit{overhead} computacional afetando o desempenho.

\textbf{Resposta:} A hipótese 2 também se confirma parcialmente. Os algoritmos de \textit{block-mapping} utilizam uma tabela de mapeamento menor, economizando espaço de memória, como descrito em \cite{FTLAlgorithms:Kwon2011}. No entanto, o \textit{overhead} computacional para realizar operações de cópia de dados para um novo bloco ao realizar uma escrita parcial pode impactar negativamente o desempenho, especialmente em cenários de escrita aleatória.

\textbf{Hipótese 3:} Algoritmos \textit{hybrid-mapping} apresentam uma balanceada combinação de eficiência, desempenho e durabilidade, adaptando-se dinamicamente a diferentes padrões de acesso aos dados.

\textbf{Resposta:} A hipótese 3 se confirma. Os algoritmos \textit{hybrid-mapping}, como BAST, FAST, LAST, CNFTL, SAST, \textit{Superblock}, EAST e PA-SSD, combinam as vantagens do mapeamento por setor/página e por bloco, buscando um equilíbrio entre eficiência, desempenho e durabilidade. Essa abordagem, ao utilizar uma tabela de mapeamento de tamanho intermediário e adaptar-se dinamicamente a diferentes padrões de acesso aos dados, geralmente apresenta um bom desempenho em diversos cenários de uso, como demonstrado em \cite{EnergyEfficiencySSD:Park2011} e \cite{FTLAlgorithms:Kwon2011}.

\textbf{Conclusão:} As hipóteses levantadas se confirmaram em parte, evidenciando a complexidade dos algoritmos \gls{ftl} e a necessidade de uma análise mais aprofundada para determinar o algoritmo ideal para cada cenário de uso. A escolha do algoritmo \gls{ftl} ideal depende de diversos fatores, como o tipo de carga de trabalho, os requisitos de desempenho, a durabilidade desejada e a eficiência no uso do espaço.


\section{Limitações da Pesquisa}
A pesquisa apresenta algumas limitações, como:

\begin{itemize}
    \item Não presença de um simulador, de modo a fazer uma análise empírica entre os algoritmos. Um simulador encontrado foi o \url{https://github.com/shehbazj/simpleFTL}.
    \item A comparação dos algoritmos é limitada a um conjunto específico de quatro aspectos.
\end{itemize}

É importante ressaltar que a análise apresentada neste capítulo se baseia em informações extraídas da literatura e não em resultados de testes práticos. A avaliação do desempenho real dos algoritmos \gls{ftl} exige a realização de testes em um ambiente controlado, utilizando um simulador ou hardware real.

%%%% CAPÍTULO 7 - CONCLUSÃO

\chapter{Conclusão}
\label{cap:conclusao}

Este trabalho investigou os algoritmos \gls{ftl} utilizados em \gls{ssd}s, analisando sua influência na eficiência no uso do espaço, durabilidade e desempenho. A pesquisa se baseou em uma revisão bibliográfica abrangente sobre os principais tipos de algoritmos \gls{ftl}, incluindo mapeamento por setor, mapeamento por bloco, mapeamento híbrido e mapeamento baseado em log.

A análise comparativa dos algoritmos revelou que o mapeamento híbrido geralmente apresenta a melhor combinação de eficiência, durabilidade e desempenho. Essa abordagem, ao combinar as vantagens do mapeamento por setor e por bloco, oferece uma solução mais flexível e adaptável a diferentes padrões de acesso aos dados.

Os algoritmos baseados em log, embora apresentem um desempenho promissor em termos de latência de escrita, podem ter um impacto variável na eficiência no uso do espaço e na durabilidade, dependendo da implementação específica.

A pesquisa também identificou algumas limitações, como a ausência de uma análise empírica utilizando um simulador.

\section{Sugestões para Futuras Pesquisas}

Com base nos resultados e limitações da pesquisa, algumas sugestões para futuras pesquisas são:

\begin{itemize}
    \item Realizar uma análise empírica utilizando um simulador de \gls{ssd}s para comparar o desempenho dos algoritmos \gls{ftl} em diferentes cenários de uso.
    \item Investigar o impacto dos algoritmos \gls{ftl} na eficiência energética dos \gls{ssd}s.
    \item Analisar o desempenho dos algoritmos \gls{ftl} em \gls{ssd}s com diferentes tipos de memória flash, como \gls{slc}, \gls{mlc}, \gls{tlc} e \gls{qlc}.
\end{itemize}

\section{Considerações Finais}

A escolha do algoritmo \gls{ftl} mais adequado para uma aplicação específica depende de diversos fatores, como o tipo de carga de trabalho, os requisitos de desempenho, a durabilidade desejada e a eficiência no uso do espaço. A pesquisa realizada neste trabalho forneceu uma visão geral dos principais tipos de algoritmos \gls{ftl} e suas características, contribuindo para a compreensão da complexidade da gestão de dados em \gls{ssd}s.

O estudo também destacou a importância de pesquisas futuras para aprofundar o conhecimento sobre os algoritmos \gls{ftl} e seus impactos em diversos aspectos, como desempenho, durabilidade, eficiência energética e segurança.
